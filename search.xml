<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2019%2F07%2F09%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas一、 canvas 绘制五角星123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p onClick="draw()"&gt;绘制&lt;/p&gt; &lt;canvas id="canvas" style="width: 500px;height:500px"&gt;&lt;/canvas&gt; &lt;script&gt; function draw() &#123; let canvas = document.getElementById("canvas"); let context = canvas.getContext("2d"); drawStar(context, 25, 10, 100, 100, 0, 1, "#FFC91F", "#FFC91F"); &#125; function drawStar( ctx, R, r, x, y, rot, borderWidth, borderStyle, fillStyle ) &#123; ctx.beginPath(); for (var i = 0; i &lt; 5; i++) &#123; ctx.lineTo( Math.cos(((18 + 72 * i - rot) / 180) * Math.PI) * R + x, -Math.sin(((18 + 72 * i - rot) / 180) * Math.PI) * R + y ); ctx.lineTo( Math.cos(((54 + 72 * i - rot) / 180) * Math.PI) * r + x, -Math.sin(((54 + 72 * i - rot) / 180) * Math.PI) * r + y ); &#125; ctx.closePath(); ctx.lineWidth = borderWidth; ctx.strokeStyle = borderStyle; ctx.fillStyle = fillStyle; ctx.fill(); ctx.stroke(); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 二、绘制圆角矩形123456789101112131415161718192021222324252627282930313233343536373839/** *绘制圆角矩形 * @param &#123;*&#125; context canvas 上下文 * @param &#123;*&#125; x 起始点x坐标 * @param &#123;*&#125; y 起始点y坐标 * @param &#123;*&#125; width 长方形宽度 * @param &#123;*&#125; height 长方形高度 * @param &#123;*&#125; r 圆角半径 * @param &#123;*&#125; lineWidth 线宽度 （可选，默认为1） * @param &#123;*&#125; strokeStyle 线颜色 （可选，默认为#000） */function drawRoundRect( context, x, y, width, height, r, lineWidth = 1, strokeStyle = "#000") &#123; context.beginPath(); context.moveTo(x, y + r); context.lineTo(x, y + height - r); context.quadraticCurveTo(x, y + height, x + r, y + height); context.lineTo(x + width - r, y + height); context.quadraticCurveTo(x + width, y + height, x + width, y + height - r); context.lineTo(x + width, y + r); context.quadraticCurveTo(x + width, y, x + width - r, y); context.lineTo(x + r, y); context.quadraticCurveTo(x, y, x, y + r); context.lineWidth = lineWidth; context.strokeStyle = strokeStyle; context.stroke();&#125;// 示例drawRoundRect(context, 10, 10, 100, 100, 10);drawRoundRect(context, 10, 10, 100, 100, 10, 5, "red");]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信小程序分享canvas总结]]></title>
    <url>%2F2019%2F07%2F03%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%ABcanvas%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、自动计算画布元素高度：123456789101112131415161718192021222324252627282930313233343536//绘制自动计算目前位置export class Queue &#123; constructor(top = 0) &#123; this.queue = []; this.startTop = top; this.endBottom = this.startTop; &#125; push(fn, style) &#123; let y = this.startTop; let prev = this.queue[this.queue.length - 1] || null; if (prev) &#123; let &#123; height = 0, marginBottom = 0 &#125; = prev.style; y = prev.y + height + marginBottom; &#125; if (style.marginTop) &#123; y += style.marginTop; &#125; let &#123; height = 0, marginBottom = 0 &#125; = style; this.endBottom = y + height + marginBottom; this.queue.push(&#123; y, style, fn &#125;); &#125; async run() &#123; if (this.queue.length &gt; 0) &#123; await Promise.all( this.queue.map(item =&gt; &#123; return item.fn(item.y); &#125;) ); &#125; return await Promise.resolve(); &#125;&#125; 具体使用： 123456789101112131415161718192021222324252627282930&lt;canvas style="width: 375px; height: 1000px;" canvas-id="canvas" class="canvas"/&gt;;const context = wx.createCanvasContext("canvas", this);// 首先new一个对象queue_2,top为距离画布圆点上方的距离let top = 10;let queue_2 = new Queue(top);await drawDashLineAndCircle(context, queue_2);async function drawDashLineAndCircle(context, queue_2) &#123; queue_2.push( async function(top) &#123; context.arc(24, top + 40, 10, 0, 2 * Math.PI); context.setFillStyle("#FFC800"); context.fill(); context.arc(24 + 327, top + 40, 10, 0, 2 * Math.PI); context.setFillStyle("#FFC800"); context.fill(); &#125;, &#123; height: 30, marginBottom: 20 &#125; );&#125;// 最后执行await queue_2.run();]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汉字转拼音]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%B1%89%E5%AD%90%E6%8B%BC%E9%9F%B3%E4%BA%92%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603var pinyin = &#123; mfkdb: [ ["A", "阿啊吖嗄腌锕"], ["Ai", "埃挨哎唉哀皑癌蔼矮艾碍爱隘捱嗳嗌嫒瑷暧砹锿霭"], ["An", "鞍氨安俺按暗岸胺案谙埯揞庵桉铵鹌黯"], ["Ang", "肮昂盎"], ["Ao", "凹敖熬翱袄傲奥懊澳坳嗷岙廒遨媪骜獒聱螯鏊鳌鏖"], ["Ba", "芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸茇菝岜灞钯粑鲅魃"], ["Bai", "白柏百摆佰败拜稗捭掰"], ["Ban", "斑班搬扳般颁板版扮拌伴瓣半办绊阪坂钣瘢癍舨"], ["Bang", "邦帮梆榜膀绑棒磅镑傍谤蒡浜"], ["Beng", "蚌崩绷甭泵蹦迸嘣甏"], ["Bao", "苞胞包褒薄雹保堡饱宝抱报暴豹鲍爆曝勹葆孢煲鸨褓趵龅"], [ "Bo", "剥玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳亳啵饽檗擘礴钹鹁簸跛踣" ], ["Bei", "杯碑悲卑北辈背贝钡倍狈备惫焙被孛陂邶蓓呗悖碚鹎褙鐾鞴"], ["Ben", "奔苯本笨畚坌锛"], [ "Bi", "逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必壁臂避陛匕俾荜荸萆薜吡哔狴庳愎滗濞弼妣婢嬖璧贲睥畀铋秕裨筚箅篦舭襞跸髀" ], [ "Pi", "辟坯砒霹批披劈琵毗啤脾疲皮匹痞僻屁譬丕仳陴邳郫圮埤鼙芘擗噼庀淠媲纰枇甓罴铍癖疋蚍蜱貔" ], ["Bian", "鞭边编贬扁便变卞辨辩辫遍匾弁苄忭汴缏煸砭碥窆褊蝙笾鳊"], ["Biao", "标彪膘表婊骠飑飙飚镖镳瘭裱鳔"], ["Bie", "鳖憋别瘪蹩"], ["Bin", "彬斌濒滨宾摈傧豳缤玢槟殡膑镔髌鬓"], ["Bing", "兵冰柄丙秉饼炳病并禀邴摒"], ["Bu", "捕卜哺补埠不布步簿部怖卟逋瓿晡钚钸醭"], ["Ca", "擦嚓礤"], ["Cai", "猜裁材才财睬踩采彩菜蔡"], ["Can", "餐参蚕残惭惨灿骖璨粲黪"], ["Cang", "苍舱仓沧藏伧"], ["Cao", "操糙槽曹草嘈漕螬艚"], ["Ce", "厕策侧册测恻"], ["Ceng", "层蹭曾噌"], ["Cha", "插叉茬茶查碴搽察岔诧猹馇汊姹杈槎檫锸镲衩"], ["Chai", "差拆柴豺侪钗瘥虿"], ["Chan", "搀掺蝉馋谗缠铲产阐颤冁谄蒇廛忏潺澶孱羼婵骣觇禅蟾躔"], ["Chang", "昌猖场尝常长偿肠厂敞畅唱倡伥鬯苌菖徜怅惝阊娼嫦昶氅鲳"], ["Chao", "超抄钞朝嘲潮巢吵炒怊晁焯耖"], ["Che", "车扯撤掣彻澈坼砗"], ["Chen", "郴臣辰尘晨忱沉陈趁衬谌谶抻嗔宸琛榇碜龀"], ["Cheng", "撑称城橙成呈乘程惩澄诚承逞骋秤丞埕枨柽塍瞠铖铛裎蛏酲"], [ "Chi", "吃痴持池迟弛驰耻齿侈尺赤翅斥炽傺墀茌叱哧啻嗤彳饬媸敕眵鸱瘛褫蚩螭笞篪豉踟魑" ], [ "Shi", "匙师失狮施湿诗尸虱十石拾时食蚀实识史矢使屎驶始式示士世柿事拭誓逝势是嗜噬适仕侍释饰氏市恃室视试谥埘莳蓍弑轼贳炻礻铈舐筮豕鲥鲺" ], ["Chong", "充冲虫崇宠重茺忡憧铳舂艟"], ["Chou", "抽酬畴踌稠愁筹仇绸瞅丑臭俦帱惆瘳雠"], ["Chu", "初出橱厨躇锄雏滁除楚础储矗搐触处亍刍怵憷绌杵楮樗褚蜍蹰黜"], ["Chuai", "揣搋嘬膪踹"], ["Chuan", "川穿椽传船喘串舛遄氚钏舡"], ["Chuang", "疮窗床闯创怆"], ["Zhuang", "幢桩庄装妆撞壮状僮"], ["Chui", "吹炊捶锤垂陲棰槌"], ["Chun", "春椿醇唇淳纯蠢莼鹑蝽"], ["Chuo", "戳绰啜辍踔龊"], ["Ci", "疵茨磁雌辞慈瓷词此刺赐次茈祠鹚糍"], ["Cong", "聪葱囱匆从丛苁淙骢琮璁枞"], ["Cou", "凑楱辏腠"], ["Cu", "粗醋簇促卒蔟徂猝殂酢蹙蹴"], ["Cuan", "蹿篡窜汆撺爨镩"], ["Cui", "摧崔催脆瘁粹淬翠萃啐悴璀榱毳"], ["Cun", "村存寸忖皴"], ["Cuo", "磋撮搓措挫错厝嵯脞锉矬痤鹾蹉"], ["Da", "搭达答瘩打大耷哒怛妲褡笪靼鞑"], ["Dai", "呆歹傣戴带殆代贷袋待逮怠埭甙呔岱迨绐玳黛"], ["Dan", "耽担丹单郸掸胆旦氮但惮淡诞蛋儋凼萏菪啖澹宕殚赕眈疸瘅聃箪"], ["Tan", "弹坍摊贪瘫滩坛檀痰潭谭谈坦毯袒碳探叹炭郯昙忐钽锬覃"], ["Dang", "当挡党荡档谠砀裆"], ["Dao", "刀捣蹈倒岛祷导到稻悼道盗叨氘焘纛"], ["De", "德得的锝"], ["Deng", "蹬灯登等瞪凳邓噔嶝戥磴镫簦"], [ "Di", "堤低滴迪敌笛狄涤嫡抵底地蒂第帝弟递缔氐籴诋谛邸坻荻嘀娣柢棣觌祗砥碲睇镝羝骶" ], ["Zhai", "翟摘斋宅窄债寨砦瘵"], ["Dian", "颠掂滇碘点典靛垫电佃甸店惦奠淀殿丶阽坫巅玷钿癜癫簟踮"], ["Diao", "碉叼雕凋刁掉吊钓铞貂鲷"], ["Tiao", "调挑条迢眺跳佻苕祧窕蜩笤粜龆鲦髫"], ["Die", "跌爹碟蝶迭谍叠垤堞喋牒瓞耋鲽"], ["Ding", "丁盯叮钉顶鼎锭定订仃啶玎腚碇町疔耵酊"], ["Diu", "丢铥"], ["Dong", "东冬董懂动栋侗恫冻洞垌咚岽峒氡胨胴硐鸫"], ["Dou", "兜抖斗陡豆逗痘蔸钭窦蚪篼"], ["Du", "都督毒犊独读堵睹赌杜镀肚度渡妒芏嘟渎椟牍蠹笃髑黩"], ["Duan", "端短锻段断缎椴煅簖"], ["Dui", "堆兑队对怼憝碓镦"], ["Dun", "墩吨蹲敦顿钝盾遁沌炖砘礅盹趸"], ["Tun", "囤吞屯臀氽饨暾豚"], ["Duo", "掇哆多夺垛躲朵跺舵剁惰堕咄哚沲缍铎裰踱"], ["E", "蛾峨鹅俄额讹娥恶厄扼遏鄂饿噩谔垩苊莪萼呃愕屙婀轭腭锇锷鹗颚鳄"], ["En", "恩蒽摁嗯"], ["Er", "而儿耳尔饵洱二贰迩珥铒鸸鲕"], ["Fa", "发罚筏伐乏阀法珐垡砝"], ["Fan", "藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛蕃蘩幡夂梵燔畈蹯"], ["Fang", "坊芳方肪房防妨仿访纺放邡枋钫舫鲂"], ["Fei", "菲非啡飞肥匪诽吠肺废沸费狒悱淝妃绯榧腓斐扉砩镄痱蜚篚翡霏鲱"], ["Fen", "芬酚吩氛分纷坟焚汾粉奋份忿愤粪偾瀵棼鲼鼢"], ["Feng", "丰封枫蜂峰锋风疯烽逢冯缝讽奉凤俸酆葑唪沣砜"], ["Fo", "佛"], ["Fou", "否缶"], [ "Fu", "夫敷肤孵扶拂辐幅氟符伏俘服浮涪福袱弗甫抚辅俯釜斧脯腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐匐凫郛芙芾苻茯莩菔拊呋呒幞怫滏艴孚驸绂绋桴赙祓黻黼罘稃馥蚨蜉蝠蝮麸趺跗鲋鳆" ], ["Ga", "噶嘎垓尬尕尜旮钆"], ["Gai", "该改概钙盖溉丐陔戤赅"], ["Gan", "干甘杆柑竿肝赶感秆敢赣坩苷尴擀泔淦澉绀橄旰矸疳酐"], ["Gang", "冈刚钢缸肛纲岗港杠戆罡筻"], ["Gao", "篙皋高膏羔糕搞镐稿告睾诰郜藁缟槔槁杲锆"], [ "Ge", "哥歌搁戈鸽胳疙割革葛格阁隔铬个各鬲仡哿圪塥嗝纥搿膈硌镉袼虼舸骼" ], ["Ha", "蛤哈铪"], ["Gei", "给"], ["Gen", "根跟亘茛哏艮"], ["Geng", "耕更庚羹埂耿梗哽赓绠鲠"], ["Gong", "工攻功恭龚供躬公宫弓巩汞拱贡共珙肱蚣觥"], ["Gou", "钩勾沟苟狗垢构购够佝诟岣遘媾缑枸觏彀笱篝鞲"], [ "Gu", "辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇嘏诂菰崮汩梏轱牯牿臌毂瞽罟钴锢鸪痼蛄酤觚鲴" ], ["Gua", "刮瓜剐寡挂褂卦诖呱栝胍鸹"], ["Guai", "乖拐怪掴"], ["Guan", "棺关官冠观管馆罐惯灌贯倌莞掼涫盥鹳鳏"], ["Guang", "光广逛咣犷桄胱"], ["Gui", "瑰规圭硅归龟闺轨鬼诡癸桂柜跪贵刽匦刿庋宄妫桧炅晷皈簋鲑鳜"], ["Gun", "辊滚棍衮绲磙鲧"], ["Guo", "锅郭国果裹过馘埚呙帼崞猓椁虢聒蜾蝈"], ["Hai", "骸孩海氦亥害骇嗨胲醢"], ["Han", "酣憨邯韩含涵寒函喊罕翰撼捍旱憾悍焊汗汉邗菡撖犴瀚晗焓顸颔蚶鼾"], ["Hang", "夯杭航行沆绗颃"], ["Hao", "壕嚎豪毫郝好耗号浩貉蒿薅嗥嚆濠灏昊皓颢蚝"], ["He", "呵喝荷菏核禾和何合盒阂河涸赫褐鹤贺诃劾壑嗬阖曷盍颌蚵翮"], ["Hei", "嘿黑"], ["Hen", "痕很狠恨"], ["Heng", "哼亨横衡恒蘅珩桁"], ["Hong", "轰哄烘虹鸿洪宏弘红黉訇讧荭蕻薨闳泓"], ["Hou", "喉侯猴吼厚候后堠後逅瘊篌糇鲎骺"], [ "Hu", "呼乎忽瑚壶葫胡蝴狐糊湖弧虎唬护互沪户冱唿囫岵猢怙惚浒滹琥槲轷觳烀煳戽扈祜瓠鹄鹕鹱笏醐斛鹘" ], ["Hua", "花哗华猾滑画划化话骅桦砉铧"], ["Huai", "槐徊怀淮坏踝"], ["Huan", "欢环桓还缓换患唤痪豢焕涣宦幻奂擐圜獾洹浣漶寰逭缳锾鲩鬟"], ["Huang", "荒慌黄磺蝗簧皇凰惶煌晃幌恍谎隍徨湟潢遑璜肓癀蟥篁鳇"], [ "Hui", "灰挥辉徽恢蛔回毁悔慧卉惠晦贿秽会烩汇讳诲绘诙茴荟蕙咴喙隳洄彗缋珲晖恚虺蟪麾" ], ["Hun", "荤昏婚魂浑混诨馄阍溷"], ["Huo", "豁活伙火获或惑霍货祸劐藿攉嚯夥钬锪镬耠蠖"], [ "Ji", "击圾基机畸稽积箕肌饥迹激讥鸡姬绩缉吉极棘辑籍集及急疾汲即嫉级挤几脊己蓟技冀季伎祭剂悸济寄寂计记既忌际妓继纪藉亟乩剞佶偈墼芨芰荠蒺蕺掎叽咭哜唧岌嵴洎屐骥畿玑楫殛戟戢赍觊犄齑矶羁嵇稷瘠虮笈笄暨跻跽霁鲚鲫髻" ], [ "Jia", "嘉枷夹佳家加荚颊贾甲钾假稼价架驾嫁伽郏葭岬浃迦珈戛胛恝铗镓痂瘕蛱笳袈跏" ], [ "Jian", "歼监坚尖笺间煎兼肩艰奸缄茧检柬碱硷拣捡简俭剪减荐槛鉴践贱见键箭件健舰剑饯渐溅涧建僭谏谫菅蒹搛湔蹇謇缣枧楗戋戬牮犍毽腱睑锏鹣裥笕翦踺鲣鞯" ], ["Jiang", "僵姜将浆江疆蒋桨奖讲匠酱降茳洚绛缰犟礓耩糨豇"], [ "Jiao", "蕉椒礁焦胶交郊浇骄娇搅铰矫侥脚狡角饺缴绞剿教酵轿较叫窖佼僬艽茭挢噍峤徼姣敫皎鹪蛟醮跤鲛" ], ["Jue", "嚼撅攫抉掘倔爵觉决诀绝厥劂谲矍蕨噘崛獗孓珏桷橛爝镢蹶觖"], [ "Jie", "揭接皆秸街阶截劫节桔杰捷睫竭洁结解姐戒芥界借介疥诫届讦诘拮喈嗟婕孑桀碣疖颉蚧羯鲒骱" ], [ "Jin", "巾筋斤金今津襟紧锦仅谨进靳晋禁近烬浸尽劲卺荩堇噤馑廑妗缙瑾槿赆觐衿矜" ], [ "Jing", "荆兢茎睛晶鲸京惊精粳经井警景颈静境敬镜径痉靖竟竞净刭儆阱菁獍憬泾迳弪婧肼胫腈旌箐" ], ["Jiong", "炯窘迥扃"], ["Jiu", "揪究纠玖韭久灸九酒厩救旧臼舅咎就疚僦啾阄柩桕鸠鹫赳鬏"], [ "Ju", "鞠拘狙疽居驹菊局咀矩举沮聚拒据巨具距踞锯俱句惧炬剧倨讵苣苴莒掬遽屦琚椐榘榉橘犋飓钜锔窭裾醵踽龃雎鞫" ], ["Juan", "捐鹃娟倦眷卷绢鄄狷涓桊蠲锩镌隽"], ["Jun", "均菌钧军君峻俊竣浚郡骏捃皲筠麇"], ["Ka", "喀咖卡佧咔胩"], ["Luo", "咯萝螺罗逻锣箩骡裸落洛骆络倮蠃荦摞猡泺漯珞椤脶镙瘰雒"], ["Kai", "开揩楷凯慨剀垲蒈忾恺铠锎锴"], ["Kan", "刊堪勘坎砍看侃莰阚戡龛瞰"], ["Kang", "康慷糠扛抗亢炕伉闶钪"], ["Kao", "考拷烤靠尻栲犒铐"], [ "Ke", "坷苛柯棵磕颗科壳咳可渴克刻客课嗑岢恪溘骒缂珂轲氪瞌钶锞稞疴窠颏蝌髁" ], ["Ken", "肯啃垦恳裉"], ["Keng", "坑吭铿"], ["Kong", "空恐孔控倥崆箜"], ["Kou", "抠口扣寇芤蔻叩囗眍筘"], ["Ku", "枯哭窟苦酷库裤刳堀喾绔骷"], ["Kua", "夸垮挎跨胯侉"], ["Kuai", "块筷侩快蒯郐哙狯浍脍"], ["Kuan", "宽款髋"], ["Kuang", "匡筐狂框矿眶旷况诓诳邝圹夼哐纩贶"], ["Kui", "亏盔岿窥葵奎魁傀馈愧溃馗匮夔隗蒉揆喹喟悝愦逵暌睽聩蝰篑跬"], ["Kun", "坤昆捆困悃阃琨锟醌鲲髡"], ["Kuo", "括扩廓阔蛞"], ["La", "垃拉喇蜡腊辣啦剌邋旯砬瘌"], ["Lai", "莱来赖崃徕涞濑赉睐铼癞籁"], ["Lan", "蓝婪栏拦篮阑兰澜谰揽览懒缆烂滥岚漤榄斓罱镧褴"], ["Lang", "琅榔狼廊郎朗浪蒗啷阆稂螂"], ["Lao", "捞劳牢老佬姥酪烙涝唠崂忉栳铑铹痨耢醪"], ["Le", "勒了仂叻泐鳓"], ["Yue", "乐曰约越跃岳粤月悦阅龠哕瀹樾刖钺"], ["Lei", "雷镭蕾磊累儡垒擂肋类泪羸诔嘞嫘缧檑耒酹"], ["Leng", "棱楞冷塄愣"], [ "Li", "厘梨犁黎篱狸离漓理李里鲤礼莉荔吏栗丽厉励砾历利傈例俐痢立粒沥隶力璃哩俪俚郦坜苈莅蓠藜呖唳喱猁溧澧逦娌嫠骊缡枥栎轹膦戾砺詈罹锂鹂疠疬蛎蜊蠡笠篥粝醴跞雳鲡鳢黧" ], ["Lia", "俩"], ["Lian", "联莲连镰廉怜涟帘敛脸链恋炼练蔹奁潋濂琏楝殓臁裢裣蠊鲢"], ["Liang", "粮凉梁粱良两辆量晾亮谅墚莨椋锒踉靓魉"], ["Liao", "撩聊僚疗燎寥辽潦撂镣廖料蓼尥嘹獠寮缭钌鹩"], ["Lie", "列裂烈劣猎冽埒捩咧洌趔躐鬣"], ["Lin", "琳林磷霖临邻鳞淋凛赁吝拎蔺啉嶙廪懔遴檩辚瞵粼躏麟"], ["Ling", "玲菱零龄铃伶羚凌灵陵岭领另令酃苓呤囹泠绫柃棂瓴聆蛉翎鲮"], ["Liu", "溜琉榴硫馏留刘瘤流柳六浏遛骝绺旒熘锍镏鹨鎏"], ["Long", "龙聋咙笼窿隆垄拢陇垅茏珑栊胧砻癃"], ["Lou", "楼娄搂篓漏陋偻蒌喽嵝镂瘘耧蝼髅"], [ "Lu", "芦卢颅庐炉掳卤虏鲁麓碌露路赂鹿潞禄录陆戮垆撸噜泸渌漉逯璐栌橹轳辂辘氇胪镥鸬鹭簏舻鲈" ], ["Lv", "驴吕铝侣旅履屡缕虑氯律率滤绿捋闾榈膂稆褛"], ["Luan", "峦挛孪滦卵乱脔娈栾鸾銮"], ["Lue", "掠略锊"], ["Lun", "抡轮伦仑沦纶论囵"], ["Ma", "妈麻玛码蚂马骂嘛吗唛犸杩蟆"], ["Mai", "埋买麦卖迈脉劢荬霾"], ["Man", "瞒馒蛮满蔓曼慢漫谩墁幔缦熳镘颟螨鳗鞔"], ["Mang", "芒茫盲氓忙莽邙漭硭蟒"], ["Mao", "猫茅锚毛矛铆卯茂冒帽貌贸袤茆峁泖瑁昴牦耄旄懋瞀蝥蟊髦"], ["Me", "么麽"], ["Mei", "玫枚梅酶霉煤眉媒镁每美昧寐妹媚莓嵋猸浼湄楣镅鹛袂魅"], [ "Mo", "没摸摹蘑模膜磨摩魔抹末莫墨默沫漠寞陌谟茉蓦馍嫫嬷殁镆秣瘼耱貊貘" ], ["Men", "门闷们扪焖懑钔"], ["Meng", "萌蒙檬盟锰猛梦孟勐甍瞢懵朦礞虻蜢蠓艋艨"], ["Mi", "眯醚靡糜迷谜弥米秘觅泌蜜密幂芈谧咪嘧猕汨宓弭脒祢敉縻麋"], ["Mian", "棉眠绵冕免勉娩缅面沔渑湎腼眄"], ["Miao", "苗描瞄藐秒渺庙妙喵邈缈杪淼眇鹋"], ["Mie", "蔑灭乜咩蠛篾"], ["Min", "民抿皿敏悯闽苠岷闵泯缗玟珉愍黾鳘"], ["Ming", "明螟鸣铭名命冥茗溟暝瞑酩"], ["Miu", "谬缪"], ["Mou", "谋牟某侔哞眸蛑鍪"], ["Mu", "拇牡亩姆母墓暮幕募慕木目睦牧穆仫坶苜沐毪钼"], ["Na", "拿哪呐钠那娜纳讷捺肭镎衲"], ["Nai", "氖乃奶耐奈鼐佴艿萘柰"], ["Nan", "南男难喃囝囡楠腩蝻赧"], ["Nang", "囊攮囔馕曩"], ["Nao", "挠脑恼闹淖孬垴呶猱瑙硇铙蛲"], ["Ne", "呢"], ["Nei", "馁内"], ["Nen", "嫩恁"], ["Neng", "能"], ["Ni", "妮霓倪泥尼拟你匿腻逆溺伲坭蘼猊怩昵旎睨铌鲵"], ["Nian", "蔫拈年碾撵捻念廿埝辇黏鲇鲶"], ["Niang", "娘酿"], ["Niao", "鸟尿茑嬲脲袅"], ["Nie", "捏聂孽啮镊镍涅陧蘖嗫颞臬蹑"], ["Nin", "您"], ["Ning", "柠狞凝宁拧泞佞咛甯聍"], ["Niu", "牛扭钮纽拗狃忸妞"], ["Nong", "脓浓农弄侬哝"], ["Nu", "奴努怒弩胬孥驽"], ["Nv", "女恧钕衄"], ["Nuan", "暖"], ["Nue", "虐疟挪"], ["Nuo", "懦糯诺傩搦喏锘"], ["O", "哦噢"], ["Ou", "欧鸥殴藕呕偶沤讴怄瓯耦"], ["Pa", "啪趴爬帕怕琶葩杷筢"], ["Pai", "拍排牌徘湃派俳蒎哌"], ["Pan", "攀潘盘磐盼畔判叛拚爿泮袢襻蟠蹒"], ["Pang", "乓庞旁耪胖彷滂逄螃"], ["Pao", "抛咆刨炮袍跑泡匏狍庖脬疱"], ["Pei", "呸胚培裴赔陪配佩沛辔帔旆锫醅霈"], ["Pen", "喷盆湓"], ["Peng", "砰抨烹澎彭蓬棚硼篷膨朋鹏捧碰堋嘭怦蟛"], ["Pian", "篇偏片骗谝骈犏胼翩蹁"], ["Piao", "飘漂瓢票剽嘌嫖缥殍瞟螵"], ["Pie", "撇瞥丿苤氕"], ["Pin", "拼频贫品聘姘嫔榀牝颦"], ["Ping", "乒坪苹萍平凭瓶评屏俜娉枰鲆"], ["Po", "坡泼颇婆破魄迫粕叵鄱珀钋钷皤笸"], ["Pou", "剖裒掊"], ["Pu", "扑铺仆莆葡菩蒲埔朴圃普浦谱瀑匍噗溥濮璞氆镤镨蹼"], [ "Qi", "期欺栖戚妻七凄漆柒沏其棋奇歧畦崎脐齐旗祈祁骑起岂乞企启契砌器气迄弃汽泣讫亓圻芑芪萁萋葺蕲嘁屺岐汔淇骐绮琪琦杞桤槭耆祺憩碛颀蛴蜞綦鳍麒" ], ["Qia", "掐恰洽葜袷髂"], [ "Qian", "牵扦钎铅千迁签仟谦乾黔钱钳前潜遣浅谴堑嵌欠歉倩佥阡芊芡茜掮岍悭慊骞搴褰缱椠肷愆钤虔箝" ], ["Qiang", "枪呛腔羌墙蔷强抢戕嫱樯戗炝锖锵镪襁蜣羟跄"], ["Qiao", "橇锹敲悄桥瞧乔侨巧鞘撬翘峭俏窍劁诮谯荞愀憔缲樵硗跷鞒"], ["Qie", "切茄且怯窃郄惬妾挈锲箧趄"], ["Qin", "钦侵亲秦琴勤芹擒禽寝沁芩揿吣嗪噙溱檎锓螓衾"], ["Qing", "青轻氢倾卿清擎晴氰情顷请庆苘圊檠磬蜻罄綮謦鲭黥"], ["Qiong", "琼穷邛茕穹蛩筇跫銎"], ["Qiu", "秋丘邱球求囚酋泅俅巯犰湫逑遒楸赇虬蚯蝤裘糗鳅鼽"], [ "Qu", "趋区蛆曲躯屈驱渠取娶龋趣去诎劬蕖蘧岖衢阒璩觑氍朐祛磲鸲癯蛐蠼麴瞿黢" ], ["Quan", "圈颧权醛泉全痊拳犬券劝诠荃犭悛绻辁畎铨蜷筌鬈"], ["Que", "缺炔瘸却鹊榷确雀阕阙悫"], ["Qun", "裙群逡"], ["Ran", "然燃冉染苒蚺髯"], ["Rang", "瓤壤攘嚷让禳穰"], ["Rao", "饶扰绕荛娆桡"], ["Re", "惹热"], ["Ren", "壬仁人忍韧任认刃妊纫仞荏饪轫稔衽"], ["Reng", "扔仍"], ["Ri", "日"], ["Rong", "戎茸蓉荣融熔溶容绒冗嵘狨榕肜蝾"], ["Rou", "揉柔肉糅蹂鞣"], ["Ru", "茹蠕儒孺如辱乳汝入褥蓐薷嚅洳溽濡缛铷襦颥"], ["Ruan", "软阮朊"], ["Rui", "蕊瑞锐芮蕤枘睿蚋"], ["Run", "闰润"], ["Ruo", "若弱偌箬"], ["Sa", "撒洒萨卅脎飒"], ["Sai", "腮鳃塞赛噻"], ["San", "三叁伞散仨彡馓毵"], ["Sang", "桑嗓丧搡磉颡"], ["Sao", "搔骚扫嫂埽缫臊瘙鳋"], ["Se", "瑟色涩啬铯穑"], ["Sen", "森"], ["Seng", "僧"], ["Sha", "莎砂杀刹沙纱傻啥煞唼歃铩痧裟霎鲨"], ["Shai", "筛晒酾"], [ "Shan", "珊苫杉山删煽衫闪陕擅赡膳善汕扇缮讪鄯芟潸姗嬗骟膻钐疝蟮舢跚鳝" ], ["Shang", "墒伤商赏晌上尚裳垧泷绱殇熵觞"], ["Shao", "梢捎稍烧芍勺韶少哨邵绍劭潲杓筲艄"], ["She", "奢赊蛇舌舍赦摄射慑涉社设厍佘揲猞滠麝"], ["Shen", "砷申呻伸身深娠绅神沈审婶甚肾慎渗什诜谂莘葚哂渖椹胂矧蜃糁"], ["Sheng", "声生甥牲升绳省盛剩胜圣嵊晟眚笙"], ["Shou", "收手首守寿授售受瘦兽狩绶艏"], [ "Shu", "蔬枢梳殊抒输叔舒淑疏书赎孰熟薯暑曙署蜀黍鼠属术述树束戍竖墅庶数漱恕丨倏塾菽摅沭澍姝纾毹腧殳秫" ], ["Shua", "刷耍唰"], ["Shuai", "摔衰甩帅蟀"], ["Shuan", "栓拴闩涮"], ["Shuang", "霜双爽孀"], ["Shui", "谁水睡税"], ["Shun", "吮瞬顺舜"], ["Shuo", "说硕朔烁蒴搠妁槊铄"], [ "Si", "斯撕嘶思私司丝死肆寺嗣四伺似饲巳厮俟兕厶咝汜泗澌姒驷缌祀锶鸶耜蛳笥" ], ["Song", "松耸怂颂送宋讼诵凇菘崧嵩忪悚淞竦"], ["Sou", "搜艘擞嗽叟薮嗖嗾馊溲飕瞍锼螋"], ["Su", "苏酥俗素速粟僳塑溯宿诉肃夙谡蔌嗉愫涑簌觫稣"], ["Suan", "酸蒜算狻"], ["Sui", "虽隋随绥髓碎岁穗遂隧祟谇荽濉邃燧眭睢"], ["Sun", "孙损笋荪狲飧榫隼"], ["Suo", "蓑梭唆缩琐索锁所唢嗦嗍娑桫挲睃羧"], ["Ta", "塌他它她塔獭挞蹋踏嗒闼溻遢榻沓铊趿鳎"], ["Tai", "胎苔抬台泰酞太态汰邰薹骀肽炱钛跆鲐"], ["Tang", "汤塘搪堂棠膛唐糖倘躺淌趟烫傥帑溏瑭樘铴镗耥螗螳羰醣"], ["Tao", "掏涛滔绦萄桃逃淘陶讨套鼗啕洮韬饕"], ["Te", "特忑慝铽"], ["Teng", "藤腾疼誊滕"], ["Ti", "梯剔踢锑提题蹄啼体替嚏惕涕剃屉倜悌逖绨缇鹈裼醍"], ["Tian", "天添填田甜恬舔腆掭忝阗殄畋"], ["Tie", "贴铁帖萜餮"], ["Ting", "厅听烃汀廷停亭庭挺艇莛葶婷梃铤蜓霆"], ["Tong", "通桐酮瞳同铜彤童桶捅筒统痛佟仝茼嗵恸潼砼"], ["Tou", "偷投头透骰"], ["Tu", "凸秃突图徒途涂屠土吐兔堍荼菟钍酴"], ["Tuan", "湍团抟彖疃"], ["Tui", "推颓腿蜕褪退忒煺"], ["Tuo", "拖托脱鸵陀驮驼椭妥拓唾佗坨庹沱柝柁橐砣箨酡跎鼍"], ["Wa", "挖哇蛙洼娃瓦袜佤娲腽"], ["Wai", "歪外崴"], ["Wan", "豌弯湾玩顽丸烷完碗挽晚皖惋宛婉万腕剜芄菀纨绾琬脘畹蜿"], ["Wang", "汪王亡枉网往旺望忘妄罔惘辋魍"], [ "Wei", "威巍微危韦违桅围唯惟为潍维苇萎委伟伪尾纬未蔚味畏胃喂魏位渭谓尉慰卫偎诿隈葳薇帏帷嵬猥猬闱沩洧涠逶娓玮韪軎炜煨痿艉鲔" ], ["Wen", "瘟温蚊文闻纹吻稳紊问刎阌汶璺攵雯"], ["Weng", "嗡翁瓮蓊蕹"], ["Wo", "挝蜗涡窝我斡卧握沃倭莴喔幄渥肟硪龌"], [ "Wu", "巫呜钨乌污诬屋无芜梧吾吴毋武五捂午舞伍侮坞戊雾晤物勿务悟误兀仵阢邬圬芴唔庑怃忤寤迕妩婺骛杌牾焐鹉鹜痦蜈鋈鼯" ], [ "Xi", "昔熙析西硒矽晰嘻吸锡牺稀息希悉膝夕惜熄烯溪汐犀檄袭席习媳喜铣洗系隙戏细僖兮隰郗菥葸蓰奚唏徙饩阋浠淅屣嬉玺樨曦觋欷歙熹禊禧皙穸蜥螅蟋舄舾羲粞翕醯蹊鼷" ], ["Xia", "瞎虾匣霞辖暇峡侠狭下厦夏吓呷狎遐瑕柙硖罅黠"], [ "Xian", "掀锨先仙鲜纤咸贤衔舷闲涎弦嫌显险现献县腺馅羡宪陷限线冼苋莶藓岘猃暹娴氙燹祆鹇痫蚬筅籼酰跣跹霰" ], ["Xiang", "相厢镶香箱襄湘乡翔祥详想响享项巷橡像向象芗葙饷庠骧缃蟓鲞飨"], [ "Xiao", "萧硝霄削哮嚣销消宵淆晓小孝校肖啸笑效哓崤潇逍骁绡枭枵蛸筱箫魈" ], [ "Xie", "楔些歇蝎鞋协挟携邪斜胁谐写械卸蟹懈泄泻谢屑偕亵勰燮薤撷獬廨渫瀣邂绁缬榭榍蹀躞" ], ["Xin", "薪芯锌欣辛新忻心信衅囟馨昕歆镡鑫"], ["Xing", "星腥猩惺兴刑型形邢醒幸杏性姓陉荇荥擤饧悻硎"], ["Xiong", "兄凶胸匈汹雄熊芎"], ["Xiu", "休修羞朽嗅锈秀袖绣咻岫馐庥溴鸺貅髹"], [ "Xu", "墟戌需虚嘘须徐许蓄酗叙旭序畜恤絮婿绪续诩勖圩蓿洫溆顼栩煦盱胥糈醑" ], ["Xuan", "轩喧宣悬旋玄选癣眩绚儇谖萱揎泫渲漩璇楦暄炫煊碹铉镟痃"], ["Xue", "靴薛学穴雪血谑噱泶踅鳕"], ["Xun", "勋熏循旬询寻驯巡殉汛训讯逊迅巽郇埙荀荨蕈薰峋徇獯恂洵浔曛醺鲟"], ["Ya", "压押鸦鸭呀丫芽牙蚜崖衙涯雅哑亚讶伢垭揠岈迓娅琊桠氩砑睚痖"], [ "Yan", "焉咽阉烟淹盐严研蜒岩延言颜阎炎沿奄掩眼衍演艳堰燕厌砚雁唁彦焰宴谚验厣赝剡俨偃兖谳郾鄢埏菸崦恹闫阏湮滟妍嫣琰檐晏胭焱罨筵酽趼魇餍鼹" ], ["Yang", "殃央鸯秧杨扬佯疡羊洋阳氧仰痒养样漾徉怏泱炀烊恙蛘鞅"], [ "Yao", "邀腰妖瑶摇尧遥窑谣姚咬舀药要耀钥夭爻吆崾徭幺珧杳轺曜肴铫鹞窈鳐" ], ["Ye", "椰噎耶爷野冶也页掖业叶曳腋夜液靥谒邺揶晔烨铘"], [ "Yi", "一壹医揖铱依伊衣颐夷遗移仪胰疑沂宜姨彝椅蚁倚已乙矣以艺抑易邑屹亿役臆逸肄疫亦裔意毅忆义益溢诣议谊译异翼翌绎刈劓佚佾诒圯埸懿苡荑薏弈奕挹弋呓咦咿噫峄嶷猗饴怿怡悒漪迤驿缢殪轶贻欹旖熠眙钇镒镱痍瘗癔翊蜴舣羿" ], [ "Yin", "茵荫因殷音阴姻吟银淫寅饮尹引隐印胤鄞垠堙茚吲喑狺夤洇氤铟瘾窨蚓霪龈" ], [ "Ying", "英樱婴鹰应缨莹萤营荧蝇迎赢盈影颖硬映嬴郢茔莺萦蓥撄嘤膺滢潆瀛瑛璎楹媵鹦瘿颍罂" ], ["Yo", "哟唷"], ["Yong", "拥佣臃痈庸雍踊蛹咏泳涌永恿勇用俑壅墉喁慵邕镛甬鳙饔"], [ "You", "幽优悠忧尤由邮铀犹油游酉有友右佑釉诱又幼卣攸侑莠莜莸尢呦囿宥柚猷牖铕疣蚰蚴蝣繇鱿黝鼬" ], [ "Yu", "迂淤于盂榆虞愚舆余俞逾鱼愉渝渔隅予娱雨与屿禹宇语羽玉域芋郁吁遇喻峪御愈欲狱育誉浴寓裕预豫驭禺毓伛俣谀谕萸蓣揄圄圉嵛狳饫馀庾阈鬻妪妤纡瑜昱觎腴欤於煜燠聿畲钰鹆鹬瘐瘀窬窳蜮蝓竽臾舁雩龉" ], [ "Yuan", "鸳渊冤元垣袁原援辕园员圆猿源缘远苑愿怨院垸塬芫掾沅媛瑗橼爰眢鸢螈箢鼋" ], ["Yun", "耘云郧匀陨允运蕴酝晕韵孕郓芸狁恽愠纭韫殒昀氲熨"], ["Za", "匝砸杂咋拶咂"], ["Zai", "栽哉灾宰载再在崽甾"], ["Zan", "咱攒暂赞瓒昝簪糌趱錾"], ["Zang", "赃脏葬奘驵臧"], ["Zao", "遭糟凿藻枣早澡蚤躁噪造皂灶燥唣"], ["Ze", "责择则泽仄赜啧帻迮昃箦舴"], ["Zei", "贼"], ["Zen", "怎谮"], ["Zeng", "增憎赠缯甑罾锃"], ["Zha", "扎喳渣札轧铡闸眨栅榨乍炸诈柞揸吒咤哳楂砟痄蚱齄"], ["Zhan", "瞻毡詹粘沾盏斩辗崭展蘸栈占战站湛绽谵搌旃"], ["Zhang", "樟章彰漳张掌涨杖丈帐账仗胀瘴障仉鄣幛嶂獐嫜璋蟑"], ["Zhao", "招昭找沼赵照罩兆肇召着诏棹钊笊"], ["Zhe", "遮折哲蛰辙者锗蔗这浙乇谪摺柘辄磔鹧褶蜇螫赭"], [ "Zhen", "珍斟真甄砧臻贞针侦枕疹诊震振镇阵帧圳蓁浈缜桢榛轸赈胗朕祯畛稹鸩箴" ], ["Zheng", "蒸挣睁征狰争怔整拯正政症郑证诤峥徵钲铮筝"], [ "Zhi", "芝枝支吱蜘知肢脂汁之织职直植殖执值侄址指止趾只旨纸志挚掷至致置帜峙制智秩稚质炙痔滞治窒卮陟郅埴芷摭帙忮彘咫骘栉枳栀桎轵轾贽胝膣祉黹雉鸷痣蛭絷酯跖踬踯豸觯" ], ["Zhong", "中盅忠钟衷终种肿仲众冢锺螽舯踵"], ["Zhou", "舟周州洲诌粥轴肘帚咒皱宙昼骤荮啁妯纣绉胄碡籀酎"], [ "Zhu", "珠株蛛朱猪诸诛逐竹烛煮拄瞩嘱主著柱助蛀贮铸筑住注祝驻伫侏邾苎茱洙渚潴杼槠橥炷铢疰瘃竺箸舳翥躅麈" ], ["Zhua", "抓爪"], ["Zhuai", "拽"], ["Zhuan", "专砖转撰赚篆啭馔颛"], ["Zhui", "椎锥追赘坠缀萑惴骓缒隹"], ["Zhun", "谆准肫窀"], ["Zhuo", "捉拙卓桌琢茁酌啄灼浊倬诼擢浞涿濯禚斫镯"], [ "Zi", "兹咨资姿滋淄孜紫仔籽滓子自渍字谘呲嵫姊孳缁梓辎赀恣眦锱秭耔笫粢趑訾龇鲻髭" ], ["Zong", "鬃棕踪宗综总纵偬腙粽"], ["Zou", "邹走奏揍诹陬鄹驺鲰"], ["Zu", "租足族祖诅阻组俎菹镞"], ["Zuan", "钻纂攥缵躜"], ["Zui", "嘴醉最罪蕞觜"], ["Zun", "尊遵撙樽鳟"], ["Zuo", "昨左佐做作坐座阼唑怍胙祚笮"], ["Ei", "诶"], ["Dia", "嗲"], ["Cen", "岑涔"], ["Nou", "耨"] ], go: function() &#123; var str = arguments[0].replace(/(^\s*)|(\s*$)/g, ""); var e = ""; var c, l1, l2; for (var i = 0; i &lt; str.length; i++) &#123; l1 = str.charAt(i); c = l1.charCodeAt(); if (c &gt; 1 &amp;&amp; c &lt; 128) &#123; //数字、字母 if (/^[A-Za-z0-9]+$/.test(l1)) &#123; e += l1; &#125; else &#123; e += " "; &#125; &#125; else &#123; //汉字 var pp = pinyin.mfkdb; var ii = 0; while (ii &lt; pp.length) &#123; if (pp[ii][1].indexOf(l1) &gt; -1) &#123; e += pp[ii][0]; break; &#125; ii++; &#125; &#125; &#125; e = e.replace(/\s/g, "_"); while (e.indexOf("__") &gt; -1) &#123; e = e.replace(/__/g, "_"); &#125; if (arguments[1] == 1) &#123; return e.toLowerCase(); &#125; else &#123; return e; &#125; &#125;&#125;;//使用方法（1）：pinyin.go('汉字'); //例：张家界 ZhangJiaJie (首字大写)//使用方法（2）：pinyin.go('汉字',1);//例：张家界 zhangjiajie (全小写)var s = pinyin.go("你的");// // 获取汉子首字母大写var arr = ["维", "我的", "你的", "aaa", "他的"];var result = arr.map(item =&gt; &#123; return pinyin .go(item) .substring(0, 1) .toUpperCase();&#125;);// 去重var array = [...new Set(result)];console.log("array", array);]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发总结]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[微信小程序开发总结(基于 uni-app)一、 实现页面向上滑动或者向下滑动时按钮隐藏，当滑动停止的时候，按钮出现 1234567891011121314151617181920212223242526272829303132&lt;view :class="!isShowWriteBtn ? 'hide_page_bottom' : '' " class="page_bottom" @click="writeWineComment"&gt; &lt;view class="write_wine_comment"&gt;写酒评&lt;/view&gt;&lt;/view&gt;&lt;style&gt; /* 写酒评 */ .page_bottom &#123; position: fixed; bottom: 70upx; left: 50%; margin-left: -90upx; width: 180upx; height: 80upx; line-height: 80upx; text-align: center; background: #ffc91f; border-radius: 36upx; box-shadow: 0 5upx 20upx #ffc91f; transition: all 0.6s ease-in-out; &#125; .hide_page_bottom &#123; bottom: -80upx; &#125; .write_wine_comment &#123; font-size: 30upx; font-weight: 500; color: rgba(51, 51, 51, 1); &#125;&lt;/style&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344export default &#123; data() &#123; return &#123; scrollTop: 0, // 页面滑动后距离顶部的距离 isShowWriteBtn: true // 是否显示底部写酒评按钮 &#125;; &#125;, onPageScroll(ev) &#123; this.handWriteBtn(ev); &#125;, methods: &#123; // 处理滑动时底部发酒评按钮显示隐藏 handWriteBtn(ev) &#123; let that = this; //判断浏览器滚动条上下滚动 if ( ev.scrollTop &gt; this.scrollTop || ev.scrollTop == uni.getSystemInfoSync().windowHeight ) &#123; //向下滚动 that.isShowWriteBtn = false; &#125; else &#123; //向上滚动 that.isShowWriteBtn = false; &#125; //给scrollTop重新赋值 setTimeout(() =&gt; &#123; that.scrollTop = ev.scrollTop; setTimeout(() =&gt; &#123; // 如果当前的scrollTop和滚动的scrollTop值相同时，表示你滑动已经停止 if (ev.scrollTop == that.scrollTop) &#123; that.isShowWriteBtn = true; &#125; &#125;, 300); &#125;); &#125;, // 写酒评 writeWineComment() &#123; // 处理函数逻辑 //this.isShowCommentModal = true; &#125; &#125;&#125;; 二、 实现文字产出两行展示更多，点击展示更多，可以显示全部文字 123456789101112131415161718192021222324252627282930&lt;view class=""&gt; &lt;view class="outer" :class="isShowMaxHeight ? 'hidden_max_height' : ''"&gt; &lt;view class="inner"&gt; 文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容 文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容文本内容1111 &lt;/view&gt; &lt;/view&gt; &lt;view v-if="isShowMoreData" class="show_more_data" @click="showMoreData" &gt;[展示更多]&lt;/view &gt;&lt;/view&gt;&lt;style&gt; .outer &#123; overflow: hidden; max-height: 80upx; &#125; .hidden_max_height &#123; max-height: 100%; &#125; .inner &#123; display: block; oveflow: auto; font-size: 30upx; line-height: 40upx; &#125; .show_more_data &#123; color: #f8b916; font-size: 30upx; &#125;&lt;/style&gt; 12345678910111213141516171819202122232425262728export default &#123; data() &#123; return &#123; isShowMoreData: false, isShowMaxHeight: false &#125;; &#125;, onLoad() &#123; let selectorQuery = uni.createSelectorQuery(); selectorQuery.select(".outer").fields(&#123; size: true &#125;); selectorQuery.select(".inner").fields(&#123; size: true &#125;); selectorQuery.exec(res =&gt; &#123; console.log("res", res); if (res[0].height &lt; res[1].height) &#123; this.isShowMoreData = true; &#125; &#125;); &#125;, methods() &#123; // 展示 更多 showMoreData() &#123; this.isShowMoreData = !this.isShowMoreData; this.isShowMaxHeight = !this.isShowMaxHeight; &#125;, &#125;&#125;; 三、uni.uploadFile 上传多张图片方法封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Config from "../config.js";import &#123; request &#125; from "./request.js";// 上传图片/** * * * @param &#123;Array&#125; imgPath 图片数组路径 * @param &#123;Number&#125; type 1：问答图片 2：用户头像 3：酒图片 */function uploadImgs(imgPath = [], type = 1) &#123; return new Promise((resolve, reject) =&gt; &#123; let promisies = imgPath.map(path =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; uni.uploadFile(&#123; url: Config.domain_name + "/server/common/v1/uploadPict", filePath: path, name: "file", formData: &#123; type: type &#125;, success: uploadFileRes =&gt; &#123; let result = JSON.parse(uploadFileRes.data); if (result &amp;&amp; result.code == 200) &#123; resolve(result.data.picUrl); &#125; else &#123; reject(result); &#125; &#125;, fail: err =&gt; &#123; reject(err); &#125; &#125;); &#125;); &#125;); return Promise.all(promisies) .then(res =&gt; &#123; resolve(res); &#125;) .catch(err =&gt; &#123; reject(err); &#125;); &#125;);&#125;module.exports = &#123; uploadImgs&#125;;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redux简要总结]]></title>
    <url>%2F2019%2F02%2F27%2Fredux%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[redux简要总结一、redux的核心概念： store action reducer store : 记录所有的状态，state action : action本质是一个对象，告诉dispath需要做什么 reducer ： reducer拿到state和action，生成新的state(根据老的状态和action来生成新的状态) 二、redux的简单使用： 首先通过reducer新建store，可以随时通过store.getState获取状态 需要更新状态的时候，store.dispatch(action)来修改状态 reducer函数接受state和action，返回新的state，可以通过store.subscrible来监听每次修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; createStore &#125; from "redux";import &#123; StringDecoder &#125; from "string_decoder";// 1. 新建reducerfunction todo (state = 10,action) &#123; switch (action.type) &#123; case 'add': return state + 1; break; case 'minus': return state - 1; break; default: return 10; break; &#125;&#125;// 2. 使用createStore(reucer),传入一个reducer来新建一个store，并且可以使用store.getState()来获取到最新的statelet store = createStore(todo);let init = store.getState();console.log(init);// 3.通过dispatch触发一个action来修改state，并且再次通过store.getState()来获取到最新的statestore.dispatch(&#123; type : 'add'&#125;)let num = store.getState();console.log(num)// 4. 这里我们也可以使用store.subscribe()来添加一个变化监听器，每当dispatch一个action的时候，state就可能已发生变化，我们就可以在回调函数里监听state的变化。function listener () &#123; let current = store.getState(); console.log('当前数值为',current);&#125;store.subscribe(listener);// 5. 此时再次触发一个action，通过stroe.subscribe()方法来监听state的变化store.dispatch(&#123; type: 'minus'&#125;) 如图:]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[letCode算法题-数组]]></title>
    <url>%2F2019%2F02%2F24%2FletCode%E7%AE%97%E6%B3%95%E9%A2%98-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[letCode算法题-数组给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 1234567891011121314151617181920212223242526272829303132333435363738var letterCombinations = function (digits) &#123; // 建立电话号码映射关系 let map = ['','','abc','def','ghi','jkl','mno','pqrs','tuv','wxyz']; // 把输入的数值变为数组 let nums = digits.split(''); let code = nums.map(item =&gt; &#123; return map[item] &#125;); // 递归 let fun = (arr) =&gt; &#123; // 临时变量用来保存前两个组合的结果 let result = []; // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素 for (let i = 0; i &lt; arr[0].length; i++) &#123; for (let j = 0; j &lt; arr[1].length; j++) &#123; result.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`); &#125; &#125; // 用前两个组合的结果用来替换前两个元素 arr.splice(0, 2, result); if (arr.length &gt; 1) &#123; fun(arr); &#125; else &#123; return result; &#125; &#125; return fun(code);&#125;; 提示： 此题解题思路需要考虑，如果有多于两个数字时，应该先考虑把前两个数字结合，然后再两两结合。 本题主要是用到了数组splice()方法，以及递归调用。 如图：]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[letCode算法题-字符串]]></title>
    <url>%2F2019%2F02%2F23%2FletCode%E7%AE%97%E6%B3%95%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[letCode算法题-字符串题目一：描述： 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 输入: “Let’s take LeetCode contest” 输出: “s’teL ekat edoCteeL tsetnoc” 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 解法一：12345678910var reverseWords = function(s) &#123; let arr = s.split(" "); let result = arr.map(item =&gt; &#123; return item.split('').reverse().join(''); &#125;); return result.join(' ');&#125;; 对于上面的代码我们还可以对其进行优化，使代码看起来更加优雅。 12345var reverseWords = function(s) &#123; return s.split(' ').map( item =&gt; &#123; return item.split("").reverse().join(""); &#125;).join(" ")&#125;; 提示： 这里使用了字符串split方法，split方法可以把一个字符串分割为一个数组,如果把””作为separator分割符，那么会把字符串每一个字符都进行分割。当然separator也开始以是一个正则表达式。 更多详情可以参照菜鸟教程split方法 1string.split(separator,limit) 解法二：提示： 此种解法使用字符串split方法用正则来匹配空格单词分割 12345var reverseWords = function(s) &#123; return s.split(/\s/g).map(item =&gt; &#123; return item.split('').reverse().join(''); &#125;).join(" ");&#125;; 解法三：12345var reverseWords = function(s) &#123; return s.match(/[\w']+/g).map( item =&gt; &#123; return item.split("").reverse().join(""); &#125;).join(" ")&#125;; 提示： 这里使用了字符串的match方法，可以用来匹配每个单词进行分割。 1string.match(regexp) 参数： 参数 描述 regexp 必需，规定要匹配的RegExp对象，如果该参数不是RegExp对象，可以使用RegExp将其转化为RegExp对象 返回值： 返回值为一个数组，用来存放匹配到的结果，,如果没有找到则返回null。 1. 更多详情可以参考菜鸟教程match 2. 菜鸟教程JavaScript RegExp 对象 3. 菜鸟教程RegExp参考手册 题目二：给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例 1 : 输入: “00110011” 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 请注意，一些重复出现的子串要计算它们出现的次数。 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 解法： 12345678910111213141516171819202122232425262728293031function f(str) &#123; let result = []; let match = (s) =&gt; &#123; // 匹配连续多个0或者多个1，并且取第一个 let j = s.match(/(0+|1+)/)[0]; // 如果取到的是0，就进行取反，然后获取长度和j一样 let o = (j[0] ^ 1).toString().repeat(j.length); let reg = new RegExp(`^($&#123;j&#125;$&#123;o&#125;)`); // 如果在子字符串中可以找到匹配的，则返回，否则返回空字符串 if(reg.test(s)) &#123; return RegExp.$1; &#125;else &#123; return ''; &#125; &#125; for(let i = 0; i &lt; str.length - 1; i++) &#123; // 从 i 开始截取到最后一个 let sub = match(str.slice(i)); if(sub) &#123; result.push(sub); &#125; &#125; return result;&#125; 提示1：这里使用到了test()方法： test()方法搜索字符串指定的值，根据结果并返回真或假。 下面的示例是从字符串中搜索字符 “e” ： 实例 var patt1=new RegExp(“e”); document.write(patt1.test(“The best things in life are free”)); 由于该字符串中存在字母 “e”，以上代码的输出将是：true 提示2：这里使用到了字符串的repeat方法，repeat() 方法字符串复制指定次数。 1string.repeat(count)]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面试题总结(二)]]></title>
    <url>%2F2019%2F02%2F22%2FJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[JavaScript面试题总结(二)一、题目一：描述：1. 获取某个页面所使用的所有标签 2. 并且统计出现次数最多的标签 第一步先获取所有的标签，并将类数组对象转化为数组，统计每一种标签出现的次数 123456789101112/** * 获取所有的标签节点，并且对每一种标签进行统计个数，返回一个对象 */function getAllTags () &#123; let nodeList = document.querySelectorAll("*"); obj = Array.from(nodeList).reduce((pre,next) =&gt; &#123; pre[next.localName] = pre[next.localName] ? ++pre[next.localName] : 1; return pre; &#125;,&#123;&#125;); return obj;&#125; 注意：1. document.querySelectorAll(&quot;*&quot;)可以获取所有的节点对象，这里的返回结果为类数组对象; 2. Array.from()可以把一个类数组对象转化为一个数组； 3. pre[next.localName] = pre[next.localName] ? ++pre，这里要注意的是，返回的类数组对象的每一项也都是一个对象，相同的节点有不同的类名也会归为一个不同项，我们可以通过判断localName来判断是否是相同的标签。 如图： 统计出现次数最多的标签 123456789101112131415function getMaxCount(obj) &#123; let result = &#123; count: 0, tag : '' &#125;; Object.keys(obj).forEach(item =&gt; &#123; if (result.count &lt; obj[item]) &#123; result.count = obj[item]; result.tag = item; &#125; &#125;) return result;&#125; 123456function getResult () &#123; let obj = getAllTags(); let result = getMaxCount(obj); return result;&#125; 上面的代码虽然解决此题，但是还有一个问题，如果有两个或者多个标签出现的次数相同并且次数最多，上面的代码并不能获取正确的结果，我们仍然需要进行改进,我们可以把getMaxCount方法进行改造。 我们可以在原有基础上，把result对象tag改变为tag数组，用来存放所有的标签，用tempTags来临时存放出现次数相同的标签。如果result.count &lt; obj[item],需要注意的是，要把tempTags临时数组清空，因为此时已经有出现次数更多的标签出现。 1234567891011121314151617181920212223242526272829303132333435363738/** * * @param &#123;object&#125; obj 要传入的类数组对象 * 返回一个对象 */function getMaxCount (obj) &#123; // 临时存储个数相同的标签 tempTags = []; /** * count : 标签个数 * tags : 出现次数相同的标签 */ let result = &#123; count : 0, tags : [] &#125;; Object.keys(obj).forEach( item =&gt; &#123; if(result.count &lt; obj[item]) &#123; result.count = obj[item]; result.tags[0] = item; // 如果有出现次数更多的标签，把临时数组置为空 tempTags = []; &#125; else if (result.count === obj[item]) &#123; tempTags.push(item); &#125; &#125;) if(tempTags.length &gt; 0) &#123; tempTags.forEach(item =&gt; &#123; result.tags.push(item); &#125;) &#125; return result;&#125; 如图： 二、题目二：描述：有A、B、C三个请求，C依赖于A和B连个请求，如何实现？ 12345678910111213141516171819202122232425let getA = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 3000);&#125;)let getB = new Promise((reolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reolve(3); &#125;, 1000);&#125;)function getC(a, b) &#123; return a + b;&#125;Promise.all([getA, getB]).then(data =&gt; &#123; console.log(data); return getC(data[0],data[1]);&#125;).then(res =&gt; &#123; console.log('res',res); // 5&#125;) 这里可以使用promise.all()来并行实现，用来提高效率。当然也可以使用async来实现，不过async是同步来执行的，可能会有一定的效率问题。 本题参考资料：1. es6中的promise.all使用问题 2. ES6 Promise 并行执行和顺序执行 3. 阮一峰es6中promise.all的使用 三、写出下列输出123456789101112var a = &#123; value : 1, func1: function () &#123; console.log(this.value) &#125;, func : () =&gt; &#123; console.log(this.value); &#125;&#125;a.func1(); // 1 a.func(); // undefined 这里主要考察了es6中的箭头函数。在a对象中，func1是一个普通函数，func是一个箭头函数，由于箭头函数使得this由动态变成静态，当我们调用a.func1()的时候this指向的为a,输出为1；在调用a.func()的时候，由于func()是一个箭头函数，使得this指向了全局对象window，window中没有value值，所以输出结果为undefined。 如果我们在全局对象中添加一个变量var value = 3，则输出结果就为3。代码如下： 1234567891011121314var a = &#123; value : 1, func1: function () &#123; console.log(this.value) &#125;, func : () =&gt; &#123; console.log(this.value); &#125;&#125;var value = 3;a.func1(); // 1 a.func(); // 3]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js模块化]]></title>
    <url>%2F2019%2F02%2F21%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[js模块化一、CommonJsnode.js的出现标志着”javaScript模块化编程”的正式诞生。因为老实说，在浏览器环境下，没有模块化并没有什么太大的影响，毕竟网页应用程序的复杂性有限。但是在服务端，一定要有模块化，与操作系统和其他应用程序互动，否则根本没法编程。Node.js是CommonJs规范的实现，webpack也是CommonJs规范的实现。 1. CommonJs定义的模块分为：① 模块引用：require，require用来引入外部模块（`require是同步的`） ② 模块定义：exports，exports对象用来导出当前模块的方法和变量，唯一的导出口 ③ 模块表示： module，module对象就代表模块本身 2. 浏览器不兼容CommonJs的原因：浏览器不兼容CommonJs的根本原因，在与浏览器缺少四个node.js环境的变量： module exports require global 注意： 只要能够提这四个变量，浏览器就可以加载CommonJs模块。 二、AMD1. AMD的出现基于CommonJs的node.js出来以后，服务端的模块概念已经形成，很自然大家就想要客户端模块。而且最好两者可以兼容，一个模块不用修改，在服务端和浏览器都可以运行。但是有一个很大的局限，使得CommonJs规范不适用于浏览器。 12const math = require('math');math.add(1,2); 第二行math.add(1,2)必须在第一行require加载完成后，才可以执行，也就是说如果加载时间很长，浏览器就会在哪里等待，因为在CommonJs中require是同步的。 上面的问题对于服务端不是一个问题，因为所有的文件都存放在本地硬盘里，可以同步加载完成，等待的时间就是硬盘的读取时间。但是对于浏览器而言，是一个大的问题，因为所有的文件都是放在服务器，等待的时间取决于网络，可能需要等待的时间比较久，浏览器处于假死状态。 因此浏览器的模块不能采用同步加载，只能使用异步方式。这就是AMD诞生的背景。 CommonJs的实现是为了后端实现而制定的，它不适合前端，AND(异步模块定义)的出现就是为了前端实现而制定的规范。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用的是异步方式加载模块，模块的加载不影响它后面的语句的执行，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，才会调用这些语句。 AMD的实现也是采用require来实现的，但是不同于CommonJs，它有两个参数： 1require([module],callback); 第一个参数[module],是一个数组，就是要加载的模块；第二个参数callback，就是加载成功之后的回调函数。如果将前面的代码改成AMD的形式，就是下面这样： 123require(['math'],function(math) &#123; math.add(1,2);&#125;) math.add()与math加载不是同步的，浏览器不会发生假死，所以很显然浏览器比较适合AMD规范。目前require.js就实现了AMD规范。 2. 为什么用require.js?最早的时候，所有的JavaScript代码都放在一个文件下，只要加载这一个文件就够了，后来代码越来越多，一个文件不够用了，必须分为两个文件或者更多文件，一次加载。就出现了这种形式： 1234&lt;script src="a.js"&gt;&lt;/script&gt;&lt;script src="b.js"&gt;&lt;/script&gt;&lt;script src="c.js"&gt;&lt;/script&gt;&lt;script src="d.js"&gt;&lt;/script&gt; 这段代码依次加载多个js文件，不过这样的写法有很大的缺点： 1. 加载的时候，浏览器会停止渲染； 2. 由于js文件之间有一定的依赖性，所以要保持js的先后顺序，否则就会出错。 require.js的出现就是为了解决以上两个问题： 1. 实现js文件的异步加载，避免网页失去响应； 2. 管理模块之间的依赖性，便于代码的编写和维护。 三、CMD大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的。 Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。Sea.js则专注于web端浏览器，同时通过node扩展的方式可以很方便跑在node环境中。 require.js想成为浏览器端的模块加载器，同时也想成为Rhino / Node等环境的模块加载器。 四、 ES6模块化参考阮一峰老师的教程 参考文献 1. js模块化编程之彻底弄懂CommonJS和AMD/CMD！ 2. require.js与Sea.js的异同 3. Javascript模块化编程（一）：模块的写法 4. Javascript模块化编程（二）：AMD规范 5. Javascript模块化编程（三）：require.js的用法 6. 阮一峰ES6 Module的语法]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue双向数据绑定简单实现]]></title>
    <url>%2F2019%2F02%2F15%2Fvue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[vue双向数据绑定简单实现一、Object.defineProperty()Object.defineProperty()允许通过属性描述对象，定义或修改属性，然后返回修改后的对象。 用法：1Object.defineProperty(object, propertyName, attributesObject) Object.defineProperty方法接受三个参数，依次如下。 属性所在的对象 属性名（它应该是一个字符串） 属性描述对象 更过细节可以参考Object.defineProperty() 1234567891011var obj = Object.defineProperty(&#123;&#125;,"name",&#123; get : function() &#123; return 'get'; &#125;, set : function(newValue) &#123; return newValue; &#125;&#125;)obj.name; // getobj.name = 'newName' // newName 二、 实现简易版双向数据绑定使用Object.defineProperty()来定义属性的set函数，属性被赋值的时候，修改Input的value值以及span中的innerHTML；然后监听input的keyup事件，修改对象的属性值，即可实现这样的一个简单的数据双向绑定。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="input"&gt; 输入的内容为：&lt;span id="text-span"&gt;&lt;/span&gt; &lt;script&gt; let input = document.getElementById('input'); let textSpan = document.getElementById('text-span'); let obj = &#123;&#125;; Object.defineProperty(obj,"inputText",&#123; set : function(newValue) &#123; input.value = newValue; textSpan.innerHTML = newValue; &#125; &#125;); input.addEventListener('keyup',function (e) &#123; obj.inputText = e.target.value; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如图：]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript执行机制]]></title>
    <url>%2F2019%2F02%2F14%2FJavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JavaScript执行机制一、关于JavaScript 众所周知，JavaScript在诞生之日就是一门单线程的非阻塞脚本语言。这是由最初的用途来决定的：与浏览器交互。 单线程意味着，JavaScript在执行代码的时候，都只有一个主线程来执行任务。 而非阻塞则是当代码需要进行一项异步任务的时候，主线程会挂起，然后在异步任务返回结果后再根据一定的规则去执行相应的回调函数。 单线程是必要的，也是JavaScript这门语言的基石，因为在浏览器中我们需要各种各样的dom操作。试想一下如果JavaScript是多线程的，那么当两个线程同时去操作同一个dom，例如一个向其添加事件，另外一个删除该dom节点，此时该如何处理，为了保证不会发生类似的事情，JavaScript选择只用一个线程来执行代码，这样就保证了程序执行的一致性。 二、 javascript事件循环JavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。 既然JavaScript是单线程，那么就像只有一个窗口的银行一样，客户需要一个个排队办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务必须排队等着。那么问题来了，如果我们想要浏览一个网页，加载一张很大的图片，难道我们要一直让网页卡着，等待图片加载完才显示吗？因此JavaScript将任务分为两类： 同步任务 异步任务 当我们打开网页的时候，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载音乐、图片、数据请求等就是异步任务。 上图的内容可以用文字来描述: 同步任务和异步任务分别进入不同的场所，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，就会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 三、 setTimeoutsetTimeout在我们的印象中就是异步执行函数，我们经常可以这样使用： 123setTimeout(() =&gt; &#123; console.log('延时3s执行');&#125;,3000); 逐渐setTimeout用的多了，问题也出现了，我们有时候写的是3s后执行，为何有时候要等4s,5s后才会执行： 12345setTimeout(() =&gt; &#123; task();&#125;,3000);console.log('console执行'); 根据前面的结论，setTimeout是异步的，应该先执行console.log()这个同步任务，所以我们的结论是先执行console.log(),然后执行task(); 然后我们修改上面的代码： 12345setTimeout(() =&gt; &#123; task();&#125;,3000);sleep(10000000); 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： setTimeout()进入到Event Table进行注册，计时开始； 执行sleep()函数； 3s到了，计时完成，task()进入到Event Queue(事件队列),但是sleep执行的比较慢，还在执行，task()处于等待执行状态； sleep()执行完成后，task()终于从Event Queue进入了主线程执行; 上述流程走完，我们知道setTimeout这个函数是经过指定时间后，把要执行的任务加入到Event Queue中然后在进入到主线程中执行，又因为js是单线程，任务要一个一个的执行，如果前面的任务还在执行，那么只能等着，导致时间会大于3s。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。 四、 JS的宏任务和微任务除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script &gt; setImmediate &gt; MessageChannel &gt; setTimeout &gt; setInterval micro-task(微任务)：process.nextTick &gt; Promise &gt; MutationObserver 不同的任务会进入到不同的Event Queue,比如setTimeout和setInterval会进入到相同的Event Queue。 事件循环的顺序决定，决定js代码的执行顺序。进入整体代码（宏任务）后，开始第一次循环，接着执行所有的微任务，然后再次从宏任务开始，找到其中一个任务队列执行完毕，在执行所有的微任务。 1234567891011setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise');&#125;).then(function() &#123; console.log('then');&#125;)console.log('console'); 这段代码作为宏任务开始执行; 遇到setTimeout()宏任务，将其回调加入到宏任务Event Queue中; 接下来遇到new Promise，立即执行，然后遇到then函数，将其分发到微任务Event Queue; 遇到console.log，立即执行； 到此，整体script代码作为第一个宏任务已经执行完了，然后去微任务Event Queue里寻找微任务进行执行，这时发现了then，并且进行执行; 第一轮事件循环结束，然后开始第二轮事件循环，当然要去宏任务Event Queue里去寻找，然后发现了setTimeout里的回调函数，然后进行执行; 事件循环，宏任务，微任务的关系如图所示： 下面代码看看执行结果如何? 123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 完整输出为：1，7，6，8，2，4，3，5，9，11，10，12。 第一轮事件循环如下： 整体script代码作为第一个宏任务进入到主线程，遇到console.log(1),输出1； 遇到setTimeout，加入到宏任务 Event Queue，这里记为setTimeout1; 遇到process.nextTick,加入到微任务 Event Queue，我们记为process1； 遇到new Promise,立即执行console.log(7),输出7，然后将then加入到微任务 Event Queue，我们记为then1； 遇到最后一个setTimeout，加入到宏任务 Event Queue，这里记为setTimeout2; 宏任务 微任务 setTimeout1 process1 setTimeout2 then1 上表示第一轮事件循环宏任务结束时，宏任务Event Queue和微任务Event Queue的情况，此时已经输出1,7； 这时有两个微任务process1和then1； 首先执行process1，输出6； 然后执行then1，输出8； 此时，第一轮事件循环已经结束，第一轮事件循环已经输出的值为：1,7,6,8；接下来执行第二轮事件循环，第二轮事件循环从setTimeout1开始。 setTimeout1中首先执行console.log(&#39;2&#39;),输出2； 然后将process.nextTick加入到微任务 Event Queue，这里记为process2； 遇到new Promise,立即执行console.log(4),输出4，然后将then加入到微任务 Event Queue，我们记为then2； 此时宏任务和微任务 Event Queue 的情况如下表： 宏任务 微任务 setTimeout2 process2 then2 第二轮事件循环宏任务执行结束后，已经输出的值为：2,4； 然后执行process2和then2两个微任务； 执行process2输出3； 执行then2输出5； 第二轮事件循环结束后输出2,4,3,5，下面开始第三轮事件循环，第三轮事件循环从setTimeout2开始。 setTimeout2中首先执行console.log(&#39;9&#39;),输出9； 然后将process.nextTick加入到微任务 Event Queue，这里记为process3； 遇到new Promise,立即执行console.log(11),输出11，然后将then加入到微任务 Event Queue，我们记为then3； 此时宏任务和微任务 Event Queue 的情况如下表： 宏任务 微任务 process3 then3 第三轮事件循环宏任务执行结束后，已经输出的值为：9,11； 然后执行process3和then3两个微任务； 执行process3输出10； 执行then3输出12； 最后第三轮事件循环结束后输出值为：9,11,10,12； 终上所述，上面代码的最后输出值为：1,7,6,8,2,4,3,5,9,11,10,12 五、 Js中async/await的执行顺序 async/await是一种异步编程的解决方案，之前的异步解决方案是回调和promise async/await是建立在promise的基础上的 async/await像promise一样，也是非阻塞的 async让异步代码看起来更像同步代码 async有返回值的情况下,async返回的是一个promise对象。 1234567async function f() &#123; console.log('async 执行了'); return 'hello';&#125;let result = f();console.log('result',result); 输出结果为： 从上面的情况可以看出，async有返回值的是一个promise对象，如果在函数中return一个直接量，async会把这个直接量通过Promise.resolve()封装成一个promised对象。 如果async没有返回值，则async返回的也是一个promise，他会通过promise.resolve()封装成一个promise对象，如： 123456async function f() &#123; console.log('async 执行了');&#125;let result = f();console.log('result',result); 输出结果为： await，就是等待，等待的是一个表达式，这个表达式的返回值可以是一个promise对象，也可以是其他值。 很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上，await是让出线程的标志。await后面的函数会先执行一遍，然后就会跳出整个async函数，来执行后面的js栈，等本轮事件循环完成了，再跳回到async函数中等待await。 await后面的返回值，如果是不是一个promise对象，则继续执行async后面的代码，如果是promise对象，则将返回的promise对象放入promise队列。 1234567891011121314151617181920212223242526272829async function async1 () &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;setTimeout(() =&gt; &#123; console.log('setTimeout');&#125;, 0);console.log('start');async1();var promise1 = new Promise((resolve,reject) =&gt; &#123; console.log('promise start'); resolve('promise1');&#125;)promise1.then(resolve =&gt; &#123; console.log(resolve);&#125;)console.log('end'); 输出结果为： 参考资料： Js中async/await的执行顺序详解]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器的协商缓存与强缓存]]></title>
    <url>%2F2019%2F01%2F29%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E4%B8%8E%E5%BC%BA%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[浏览器的协商缓存与强缓存一、什么是浏览器缓存？浏览器缓存是用户在本地磁盘对用户最近请求的文档进行存储，当访问者再次访问同一资源时，浏览器就可以从本地磁盘加载文档。 二、浏览器缓存的优点 减少冗余的数据传输，节省网费； 减少服务器的负担，大大提升网站的性能； 加快客户端加载网页的速度。 三、浏览器缓存的分类浏览器缓存的分类主要为两类，分别是协商缓存和强制缓存。 浏览器在第一次请求获取资源之后，然后根据返回的信息判断来告诉浏览器如何缓存，可能采用的是强制缓存，也可能是告诉浏览器进行协商缓存，这都是需要根据响应的header来决定。 浏览器第一次请求时： 如图: 浏览器再次进行请求时： 如图: 从上图可以看出浏览器缓存包含两种类型，即强缓存和协商缓存,浏览器在第一次请求后，当再次请求时，过程如下： 浏览器在请求某一资源时，会首先获取header 信息，判断是否命中强缓存（cache-control和expires），如果命中则直接从缓存的资源中读取信息，包括缓存的header信息，本次请求就不会与服务器进行通信； 如果本次请求没有命中强缓存，浏览器会发送请求到服务器，请求时会携带一些有关缓存中的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求的header字段信息来比较是否进行协商缓存，如果命中协商缓存，则服务器返回新的响应header信息，但是并不放回资源内容，它会告诉浏览器可以直接从缓存中读取资源，否则返回新的资源内容。 强缓存与协商缓存的比价： 缓存分类 获取资源形式 状态码 是否发送请求到服务器 强缓存 从缓存获取 200（from cache） 否，直接从缓存获取 协商缓存 从缓存获取 304（not modified） 是，请求服务器，通过服务器来告知，缓存是否可用 四、强缓存相关的header字段强缓存直接从缓存中获取资源而不经过服务器；与强缓存相关的header字段有两个： 1.expires，这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 20 Jun 2019 10:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源；（一般指服务器时间） 2.cache-control：max-age=number，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值： no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 注意： Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。 五、协商缓存协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。 1. Last-Modify/If-Modify-Since浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2019 23:59:59 GMT。 当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。 2. ETag/If-None-Match：与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。 与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。 3. 为什么要有Etag？你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间。 注意： Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 六、用户的行为对缓存的影响 用户操作 Expires/Cache-Control Last-Modied/Etag 地址栏回车 有效 有效 页面链接跳转 有效 有效 开窗口 有效 有效 前进回退 有效 有效 F5刷新 无效 有效 Ctrl+F5强制刷新 无效 无效 七、实际问题代码更新到线上后用户浏览器不能自行更新，我们不能要求客户在系统更新后都进行一次缓存清理的操作，我们该如何做？ 在资源请求的URL中增加一个参数，比如：js/index.js?ver=0.0.1。这个参数是一个版本号，每一次部署的时候变更一下，当这个参数变化的时候，强缓存都会失效并重新加载。这样一来，静态资源，部署以后就需要重新加载。这样就比较完美的解决了问题。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面试题总结(一)]]></title>
    <url>%2F2019%2F01%2F22%2FJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[JavaScript面试题总结题目一：12345678910var a = 1;if(!(b in window)) &#123; var b = 2; a += 1;&#125;else &#123; a += 2;&#125;console.log(a) // 3 console.log(b) // undefined 上面的代码可以理解为：在if条件中，变量提升，可以把b提升到作用域顶部，又因为undefined是window的一个全局变量，所以b in window返回true，执行结果为3 undefined 1234567891011var a = 1;var b;if(!(b in window)) &#123; // undefined in window 返回true，因为undefined是window的一个全局变量 b = 2; a += 1;&#125;else &#123; a += 2;&#125;console.log(a)console.log(b) 题目二：1234567891011121314var m = 1;function log() &#123; var m = 2; return function () &#123; // 闭包 m += 1; &#125;&#125;var _log = log(); // function () &#123; m += 1 &#125; 这里的m是log函数里的局部变量m=2_log(); // 把log函数里的m+1，此时局部变量m 为3console.log(m); // 这里的m为全局变量m ,所以为1 题目三：代码一： 123456789var array = [1,2,3];function test (arr) &#123; arr = [];&#125;test(array);console.log(array); // [1,2,3]; 很多人会以为此题的答案是[],而实际上是 [1,2,3],其实我们只需要明白一点，函数传参是按值传递而不是按引用传递的。 js传递参数: js中所有函数参数的传递都是按值传递的，也就是说，函数外部的值复制给函数内部的参数，就和把一个变量的值复制到另外一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同应用类型变量的复制一样。 上面的代码改成如下，代码二： 123456789var array = [1,2,3];function test(arr) &#123; arr.push(4);&#125;test(array);console.log(array); [1, 2, 3, 4] 代码一中的是把外部变量array复制一份传递给参数arr,然后在函数内部，又重新赋值为一个空数组，这里切断了他与外部变量array的联系，也就是改变了指针的执向，而外部array还是执向原来堆内存中的数组对象，这时堆内存里相当于有两个数组对象。代码二中，它们执向的是同一个堆内存中的数组对象，所以在函数内部改变数组，会影响到外部。 题目四：12345678910111213141516171819202122232425262728293031323334353637// 1. 任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。// 2. 私有变量包括函数的参数、局部变量和在函数内部定义的其他函数function Foo () &#123; function getName() &#123; // 在函数内部定义了一个函数（Foo的私有变量） console.log(1); &#125; return this;&#125;// 在函数Foo上定义了一个静态方法Foo.getName = function() &#123; console.log(2);&#125;// 在Foo的原型对象上定义了一个共享方法Foo.prototype.getName = function () &#123; console.log(3);&#125;// 函数表达式var getName = function () &#123; console.log(4);&#125;// 函数声明function getName () &#123; console.log(5);&#125;Foo.getName(); // 2getName(); // 4Foo().getName(); // 4getName(); // 4 上面的代码可以理解为下面这样：12345678910111213141516171819202122232425262728293031323334353637function Foo () &#123; function getName() &#123; // 在函数内部定义了一个函数（Foo的私有变量） console.log(1); &#125; return this;&#125;// 函数声明(函数提升)function getName () &#123; console.log(5);&#125;// 变量提升var getName;// 在函数Foo上定义了一个静态方法,函数的静态静态方法和静态属性只能通过构造函数来访问，实例访问不到Foo.getName = function() &#123; console.log(2);&#125;// 在Foo的原型对象上定义了一个共享方法Foo.prototype.getName = function () &#123; console.log(3);&#125;// 函数表达式getName = function () &#123; console.log(4);&#125;Foo.getName(); // 2getName(); // 4Foo().getName(); // 4getName(); // 4 在上面的题目中，主要考察了js 的function为什么可以添加属性,类的静态方法，变量提升，原型对象，理解这几个知识点就可以了。 js 的function为什么可以添加属性? 12345678910111213141516// 1.构造函数的是公有属性function person()&#123; this.name = 'Tom';&#125;// 构造函数的静态属性function person()&#123;&#125;person.name = 'Tom';// 构造函数的原型共享属性function person()&#123;&#125;person.prototype.name = 'Tom' 解释： ①因为在js里函数也是对象，是Function的实例，function person(){ }; person.name = &#39;Tom&#39;;这是函数对象上直接定义了name属性，只能通过函数名访问，不能通过实例对象访问；②因为Js里面函数也是对象，函数其实也有另外一种写法，var message = new Function(&#39;msg&#39;,&#39;alert(msg)&#39;); // 等价于：function message(msg) { alert(msg); };函数也是new出来的，所以函数其实也是一个对象。所以对象可以添加属性。 类的静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod() // foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 变量提升(参考JavaScript 变量提升):JavaScript 变量提升 原型对象(参考js对象和原型链)js对象和原型链 参考文献： js 的function为什么可以添加属性 阮一峰老师es6教程 《JavaScript高级程序设计》第四章 4.1.3 传递参数]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 变量提升]]></title>
    <url>%2F2019%2F01%2F22%2FJavaScript-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[JavaScript 变量提升一、概念：JavaScript中函数以及变量的声明都会提升到函数的最顶部。变量可以在使用后声明，也就是说变量可以先使用在声明。 变量提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。 二、javaScript中只有声明的变量会提升，初始化的值不会如下代码： 123var a = 10;console.log(a + b); // NaNvar b = 10; 这是因为变量声明 (var b) 提升了，但是初始化(b = 10) 并不会提升，所以 a + b 为NaN; 三、JavaScript简单解析机制浏览器JavaScript引擎遇到script标签就会对js进行预解析，将变量var 和function声明提升，但是不会执行function，然后就进入上下文执行，上下文执行还是执行预解析同样的操作，直到没有var和function，就开始执行上下文。 如： 1234567a = 1;f();var a;function f() &#123; conole.log('0000')&#125;; 预解析：1234567function f() &#123; console.log('0000)&#125;;var a ;a = 1;f(); 上面除了函数声明方式以外还可以用匿名函数的方式。 如： 123var f = function () &#123;&#125;;f(); 注意： 1. 函数声明提升直接把整个函数提升到执行环境的最顶端，所以上面的f()提升后是function f() {}; 2. 函数优先，虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量; 3. 使用匿名函数的方式不存在函数提升，因为函数声明使用的是变量表示的，所以匿名函数不存在函数提升，只存在变量提升。 如： 12345678910var f = function () &#123; console.log(2);&#125;function f() &#123; console.log(1);&#125;f(); // 2 预解析: 1234567891011function f() &#123; console.log(1);&#125;var f;f = function () &#123; console.log(2);&#125;f() 这里的输出结果是2 还有另外一种情况，如： 123456789f(); // 1function f() &#123; console.log(1);&#125;var f = function () &#123; console.log(2);&#125; 所以这里的输出为1，因为这里的函数表达式（匿名函数）不会被函数提升，就像上面的预解析一样，f虽然也被提升了，但是他是当做了一个变量，因为这个时候f是通过var f声明的变量，只不过他指向了一个函数，所以他提升后的代码等价于下面的预解析代码： 预解析： 1234567891011function f() &#123; console.log(1);&#125;var f;f();f = function () &#123; console.log(2);&#125; 四、let和constvar命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let、const命令改变了语法行为，let、const声明的变量只在它所在的代码块有效，它所声明的变量一定要在声明后使用，否则报错。 1234567// ar 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[同源策略以及跨域]]></title>
    <url>%2F2019%2F01%2F15%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[同源策略以及跨域一、同源策略同源策略(Same-Origin Policy)。所谓的 同源 是域名、协议、端口号相同。不同的客户端脚本（javascript，ActionScript）在没有授权的情况下，不能读取对方资源。简单来说，浏览器允许包含在页面A的脚本访问第二个页面B的数据资源，这一切是建立在A和B页面是同源的基础上。 二、跨域与跨域请求跨域 简单的来说，指的是两个资源非同源。出于安全方面的考虑，页面中的JavaScript在请求非同源的资源时就会出 跨域问题 ——即跨域请求，这时，由于同源策略，我们的请求会被浏览器禁止。也就出现了 我们常说的 跨域 问题。 下面，我们看一下，具体哪些情况会出现跨域问题(具体策略限制)： 三、跨域解决方案1. JSONP跨域为了便于客户端使用数据，逐渐形成了一种非正式传输协议。人们把它称作JSONP。该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 JSONP实现原理: js 请求资源会被限制，但是在页面中，script标签是没有限制的，img，iframe标签也是一样的； 通过sctipt标签的src属性，请求服务器，并且通过参数（如：?callback=func,func为本地的一个方法）,告诉服务器返回指定格式的js脚本，并将数据封装在此脚本中； 服务器在配合客户端返回一段脚本(如：{count: 1, start: 0, total: 1572}),其实返回的就是客户端一个本地的可执行方法，并且将要返回的数据封装在了参数里; 请求到资源后，本地就会执行此方法，通过对参数的处理，也就获取到了我们所要的数据。 假如我们想要请求豆瓣API的接口去获取数据https://api.douban.com/v2/book/search?q=javascript&amp;count=1，直接在浏览器里输入地址请求可以返回数据，是没有问题的。如图： 但是如果我们执行下下面一段代码的时候可能会出现跨域问题而报错。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JSONP跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;script&gt; window.onload = function()&#123; let btn = document.getElementById('btn'); btn.onclick = function () &#123; let xhr = new XMLHttpRequest(); //豆瓣图书API地址 let url = 'https://api.douban.com/v2/book/search?q=javascript&amp;count=1' xhr.open('get',url); xhr.send(); if(xhr.readystateonchange == 4 &amp;&amp; xhr.status == 200) &#123; console.log('success',xhr.response); &#125;else&#123; console.log('err',xhr); &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器截图为： 当出现上述情况时，客户端请求页面和服务端不属于同源，已经出现了跨域，这时我们可以使用JSONP来解决上述问题。 JSONP跨域客户端的具体实现： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JSONP跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //回调函数 function handleResponse(response) &#123; console.log('success...',response); &#125; window.onload = function ()&#123; let btn = document.getElementById('btn'); btn.onclick = function() &#123; //创建一个script标签 let script = document.createElement('script'); //设置srript的src script.src = "https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse"; //插入到文档中 document.body.insertBefore(script,document.body.firstChild) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器截图为： 2. postMessage跨域window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后（e.g., 在该方法之后设置的事件、之前设置的timeout 事件,etc.）向目标窗口派发一个 MessageEvent 消息。 该MessageEvent消息有四个属性需要注意： message 属性表示该message 的类型； data 属性为 window.postMessage 的第一个参数；origin 属性表示调用window.postMessage() 方法时调用页面的当前状态； source 属性记录调用 window.postMessage() 方法的窗口信息。 语法： 1otherWindow.postMessage(message, targetOrigin, [transfer]); 参数： otherWindow ： 其他窗口的一个引用，比如在A页面中使用的window； message ： 将要发送到其他 window的数据； targetOrigin ：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI； transfer(可选) ： 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 示例代码如下： 123456789// postMessage// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息window.postMessage('data', 'http://B.com');// 在窗口B中监听window.addEventListener('message', function (event) &#123; console.log(event.origin); console.log(event.source); console.log(event.data);&#125;, false); 3. WebSocketWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 特点： 没有同源限制，客户端可以与任意服务器通信。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 12345678910111213141516var ws = new WebSocket("wss://echo.websocket.org");ws.onopen = function(evt) &#123; console.log("Connection open ..."); ws.send("Hello WebSockets!");&#125;;ws.onmessage = function(evt) &#123; console.log( "Received Message: " + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log("Connection closed.");&#125;; 浏览器截图如下： 详情参考阮一峰老师的WebSocket 教程 4. CORSCORS需要浏览器和服务器的同时支持。目前所有的浏览器都支持，IE浏览器不能低于IE10。 整个CORS通信的过程都是浏览器自动完成的，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样，浏览器一旦发现AJAX请求，就会添加一些附加头信息，有时还会多出一次附加请求，但是用户不会有感觉。因此实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以实现跨源通信了。 详情参考阮一峰老师的跨域资源共享 CORS 详解]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js对象和instanceof底层原理以及typeof的使用]]></title>
    <url>%2F2019%2F01%2F15%2Fjs%E5%AF%B9%E8%B1%A1%E5%92%8Cinstanceof%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Atypeof%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[js原型链和instanceof底层原理以及typeof的使用一、typeof操作符鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型—— typeof 就是负责提供这方面信息的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串。 变量值类型 typof返回值 值未定义 undefined 布尔值 boolean 字符串 string 数值 number 对象或null object 函数 function 123456789101112131415var a;var b = null;var s = '123';var d = true;var o = &#123;&#125;;var f = function () &#123;&#125;;var num = 123;console.log(typeof a); // undefinedconsole.log(typeof b); // objectconsole.log(typeof s); // stringconsole.log(typeof d); // booleanconsole.log(typeof o); // objectconsole.log(typeof f); // functionconsole.log(typeof num); // number 二、instanceofinstanceof 可以判断一个引用对象是否属于某构造函数，instanceof的判断逻辑是从当前对象引用的__proto__顺着原型链一层一层网上找，是否能够找到对应的prototype，如果找到了就返回true，否则返回false。 模拟instanceof的实现 123456789101112131415161718192021/** * * @param &#123;Object&#125; L instanceof左侧的参数 * @param &#123;Function&#125; R instanceof右侧的参数*/function instance_of (L,R) &#123; let r = R.prototype; // 取R的显示原型 let l = L.__proto__; // 取L的隐式原型 while (true) &#123; // null 不是任何对象的实例，如果左侧为null的话，直接返回false if(L === null) &#123; return false; &#125; if(l === r) &#123; // 当R的显示原型和L的隐式原型相等时返回true return true; &#125; l = l.__proto__; &#125;&#125; 使用instanceof时有两种情况需要考虑： 第一种情况：没有发生继承时； 第二种情况：发生继承时； 第一种情况：没有发生继承时123456789101112131415161718function Parent (gender) &#123; this.gender = gender;&#125;function Child (name,age) &#123; this.name = name; this.age = age;&#125;let c = new Child('tom',20);let p = new Parent('男');console.log(c instanceof Child); // trueconsole.log(p instanceof Parent); // trueconsole.log( c instanceof Object); // trueconsole.log( p instanceof Object); // true 没有发生继承时，instanceof的工作流程分析： 123456789101112131415function instance_of (L,R) &#123; let r = R.prototype; // r为Child.prototype let l = L.__proto__; // l为c.__proto__ while (true) &#123; if(L === null) &#123; // 不通过 return false; &#125; if(l === r) &#123; // 判断 此时l为c.__proto__ 和r为Child.prototype是否相等 return true; &#125; l = l.__proto__; &#125;&#125; 上面的代码中执行c instanceof Parent的时候，l和r执向的是同一个原型对象，所以返回true 第二种情况：发生继承时123456789101112131415161718function Parent (gender) &#123; this.gender = gender;&#125;function Child (name,age,gender) &#123; Parent.call(this,gender); this.name = name; this.age = age;&#125;Child.prototype = new Parent(); // 改变了原型指向，实现继承var c = new Child('tom',20,'男');console.log( c instanceof Child); // trueconsole.log( c instanceof Parent); // trueconsole.log( c instanceof Object); // true 发生继承时，instanceof的工作流程分析： ① 首先看一下c instanceof Child 123456789101112131415function instance_of (L,R) &#123; let r = R.prototype; // r为Parent的实例p let l = L.__proto__; // l也为Parent的实例p while (true) &#123; if(L === null) &#123; // 不通过 return false; &#125; if(l === r) &#123; // 判断 此时l为Parent的实例p 和r为Parent的实例p相等 return true; &#125; l = l.__proto__; &#125;&#125; 即使发生了原型继承，c instanceof Child 依然是成立的 ② 再看一下c instanceof Parent 123456789101112131415function instance_of (L,R) &#123; let r = R.prototype; // r为Parent.prototype let l = L.__proto__; // l也为Parent的实例p while (true) &#123; if(L === null) &#123; // 不通过 return false; &#125; if(l === r) &#123; // 判断 此时l为Parent的实例p 和r为Parent.prototypepb不相等 return true; &#125; l = l.__proto__; // 此时l为Parent.prototype &#125;&#125; c instanceof Parent返回值为true，这就证明了c继承了Parent。 结论： 用于判断一个引用类型是否属于某构造函数； 还可以在继承关系中用来判断一个实例是否属于它的父类型。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6中promise的用法]]></title>
    <url>%2F2019%2F01%2F14%2FES6%E4%B8%ADpromise%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[promise的基本使用一、promise的含义： promise是异步编程的一种解决方案，比传统的回调函数和事件更加强大、合理。 promise就是一个容器，里面保存着某个未来才会结束的事件的结果。 二、promise对象的特点： 对象的状态不受外界的影响。promise对象代表一个异步操作，有三种状态:pending(进行中),fulfilled(已成功),reject(已失败)。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 状态一旦改变，就不会再变回来。promise对象状态的改变只能有两种情况：从pending到reject和从pending到fulfilled。 三、promise的用法： promise对象是一个构造函数，用来生成promise实例。 12345678910111213const promise = new Promise(function (resolve,reject) &#123; if(/*success*/) &#123; // 当promise对象从pending到resolved后执行 resolve(data); &#125;else &#123; // 当promise对象从pending到rejected后执行 reject(data); &#125;&#125;)promise.then(data =&gt; &#123; console.log('data',data);&#125;，err =&gt; &#123; throw new Error(err);&#125;) 模拟promise异步过程：得到一个随机数，如果这个随机数大于0.8则执行resolved，否则执行rejected。 12345678910111213141516function getRandom() &#123; let random = Math.random(); return new Promise((resolve,reject) =&gt; &#123; if(random &lt;= 0.8) &#123; setTimeout(resolve,500,random) &#125;else &#123; setTimeout(reject,500,random); &#125; &#125;)&#125;getRandom().then(res =&gt; &#123; console.log(`成功了,$&#123;res&#125;`);&#125;,err =&gt; &#123; console.log(`失败了,$&#123;err&#125;`);&#125;) promise新建后就会执行 1234567891011121314let promise = new Promise((resolve,rejcet) =&gt; &#123; console.log('promise'); resolve();&#125;)promise.then(res =&gt; &#123; console.log('resolved');&#125;)console.log('hello');// promise// hello// resolved promise在新建后会立即执行，所以首先输出的是promise,然后输出hello,最后在本脚本所有的同步任务执行完成后，才会执行then方法指定的回调函数，所以resolved最后输出。 promise对象中，如果调用resolve和reject函数时带有参数，那么他们的参数可以传递给then的回调函数，resolve和reject函数的参数除了可以正常值以外，还可以是另外一个promise实例。 1234567891011121314let promise_1 = new Promise((resolve,reject) =&gt; &#123; // 模拟1s后从pending到resolved setTimeout(resolve,1000,'success');&#125;);// 模拟一个promise对象接受另外一个promise成功的状态let promise_2 = new Promise((resolve,reject) =&gt; &#123; resolve(promise_1);&#125;)promise_2.then(res =&gt; &#123; console.log(res);&#125;) 123456789101112131415let promise_3 = new Promise((resolve, reject) =&gt; &#123; // 模拟1s后从 pending到rejected setTimeout(reject,1000,'failed');&#125;);// 模拟一个promise对象接受另外一个promise失败的状态let promise_4 = new Promise((resolve,reject) =&gt; &#123; resolve(promise_3);&#125;)promise_4.then(res =&gt; &#123; console.log(res);&#125;,err =&gt; &#123; console.log(err);&#125;) 上面代码promise_2中的resolve接收promise_1对象作为参数，此时，1s后promise_1执行成功，并且把promise_1的执行结果传递给Promise_2;promise_4中的resolve接收promise_3对象作为参数，此时，1s后promise_1执行失败，并且把promise_1的执行结果传递给Promise_4; 四、promise.prototype.then() promise实例具有then方法，也就是说，then方法是定义在原型对象上Promise.prototype上的，它的作用就是为promise实例状态改变时添加回调函数； then方法返回的是一个心得promise实例，因此可以采用链式写法，即then方法后面可以在调用另外一个then方法。 123456789let promise_1 = new Promise((resolve,reject) =&gt; &#123; resolve('success');&#125;)promise_1.then(res =&gt; &#123; return res;&#125;).then(res =&gt; &#123; console.log(res); // success&#125;) 上面的代码，使用then方法，依次指定了两个回调函数。第一个then中的回调函数完成后，会将返回的结果作为参数，传入第二个then中的回调函数。第二个回调函数会等待第一个回调函数完成后才会执行。 五、promise.prototype.catch()promise.prototype.catch()方法是.then(null,err=&gt; {})或者.then(undefined,err=&gt;{})的别名，用于指定错误发生时的回调函数。 123456789101112131415161718192021222324252627282930313233// 推荐写法let promise_1 = new Promise((resolve,reject) =&gt; &#123; reject('error');&#125;)promise_1.then(res =&gt; &#123; return res;&#125;).catch(err =&gt; &#123; console.log(err);&#125;)// 等同于let promise_1 = new Promise((resolve, reject) =&gt; &#123; reject('error');&#125;)promise_1.then(res =&gt; &#123; return res;&#125;,err =&gt; &#123; console.log(err);&#125;)// 等同于let promise_1 = new Promise((resolve, reject) =&gt; &#123; reject('error');&#125;)promise_1.then(res =&gt; &#123; return res;&#125;).then(null,err =&gt; &#123; console.log(err);&#125;) 六、promise.prototype.finally()finally方法用于指定不管promise最后的状态是成功还是失败都会执行的操作。finally方法不接收任何参数，finally里面的操作应该是与状态无关的。 123456789let promise = new Promise((resolve,reject) =&gt; &#123; resolve('success');&#125;)promise.then(res =&gt; &#123; return res;&#125;).finally(() =&gt; &#123; console.log('finally');&#125;) 七、promise.all()promise.all()方法用于将多个promise实例，包装成一个新的promise实例。 1let p = Promise.all([p1,p2,p3]); 新的p实例的状态由p1,p2,p3的状态决定： 只有p1,p2,p3的状态都为fulfilled，p的状态才会变为fulfilled，此时p1,p2,p3的返回值组成一个数组，传递给p的回调函数； 只要p1,p2,p3的状态有一个为rejected，p的状态才会变为rejected，此时第一个被rejected的实例的返回值，会传递给p的回调函数； 12345678910111213141516171819202122232425262728293031// 三个都为fulfilled的情况 let promise = [1,2,3].map(item =&gt; &#123; return new Promise((resolve,reject) =&gt; &#123; resolve(item); &#125;)&#125;)Promise.all(promise).then(res =&gt; &#123; console.log('success',res); // success [ 1, 2, 3 ]&#125;).catch(err =&gt; &#123; console.log('err',err);&#125;) // 有一个为rejected的情况let promise = [1, 2, 3].map(item =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if(item == 2) &#123; reject(item); &#125;else &#123; resolve(item); &#125; &#125;)&#125;)Promise.all(promise).then(res =&gt; &#123; console.log('success',res);&#125;).catch(err =&gt; &#123; console.log('err',err); // err 2&#125;) 八、promise.race()promise.race()方法同样将多个promise实例，包装成一个新的promise实例。 1let p = Promise.race([p1,p2,p3]); 新的p实例的状态由p1,p2,p3的状态决定： 只要p1,p2,p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的promise的实例返回的值，就传递给p的回调函数。 12345678910111213141516let promise = [1, 2, 3].map(item =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if(item == 2) &#123; reject(item); &#125;else &#123; resolve(item); &#125; &#125;)&#125;)Promise.race(promise).then(res =&gt; &#123; console.log('success', res); // success 1&#125;).catch(err =&gt; &#123; console.log('err',err);&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6中class的用法]]></title>
    <url>%2F2019%2F01%2F14%2FES6%E4%B8%ADclass%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[class的基本使用一、es6的 class 与es5 的构造函数123456789101112131415161718192021// es6 classclass Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; getName () &#123; console.log('get name',this.name); &#125;&#125;// es5 构造函数function Person (name,age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function () &#123; console.log('get name',this.name);&#125; class 里面的constructor方法就是构造方法，而this关键字则代表实例对象; 也就是说es5的构造函数Person，对应的就是es6的Person类的constructor方法。 二、class的数据类型与constructor的指向123456789101112class Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; getName () &#123; console.log('get name',this.name); &#125;&#125;typeof Person // "function"Person.prototype.constructor === Person // true typeof Person 打印结果是”function”,表名类的数据类型就是函数; Person.prototype.constructor === Person打印结构是true,表名类本身就指向构造函数。 三、构造函数的prototype属性，在es6中继续存在，实际上es6中class的所有方法都是定义在类的prototype属性上的12345678910111213141516class Person &#123; constructor (name,age) &#123; this.name = name; this.age = age; &#125; getName () &#123; console.log('get name',this.name); &#125;&#125;// 等同于Person.prototype = &#123; constructor() &#123;&#125;, getName() &#123;&#125;,&#125; 四、constructor方法constructor方法是类默认的构造方法，通过new命令生成实例对象，自动调用该方法，一个类必须有一个constructor方法，如果没有显示定义，则会默认添加。 12345678class Person &#123;&#125;// 等同于class Person &#123; constructor()&#123;&#125;&#125; constructor方法默认返回实例对象(即this)，完全可以指定返回另外一个对象。 12345class Person &#123; constructor() &#123; return Object.create(null); &#125;&#125; 五、this指向 类的方法内部如果含有this，则默认指向类的实例; 如果单独使用，很可能报错; 12345678910111213141516171819202122class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; getName() &#123; console.log('get name'); this.getAge(); &#125; getAge() &#123; console.log('get age',this.age); &#125;&#125;let p = new Person('jack',20);p.getName(); const &#123; getName &#125; = p;getName(); // TypeError: Cannot read property 'getAge' of undefined getName 方法中的this默认指向类的实例p; 如果const { getName } = p,将这个方法单独提取出来，this会指向当前指向环境，而不是当前实例对象,会因为找不到getAge()方法而报错; 解决方案一：在构造方法中绑定this123456789101112131415161718192021222324class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; // 在constructor方法中绑定this this.getName = this.getName.bind(this); &#125; getName() &#123; console.log('get name'); this.getAge(); &#125; getAge() &#123; console.log('get age', this.age); &#125;&#125;let p = new Person('jack', 20);p.getName();const &#123; getName &#125; = p;getName(); 解决方案二：箭头函数12345678910111213141516171819202122class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; getName = () =&gt; &#123; console.log('get name'); this.getAge(); &#125; getAge() &#123; console.log('get age', this.age); &#125;&#125;let p = new Person('jack', 20);p.getName();const &#123; getName &#125; = p;getName(); 六、类的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前面加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为静态方法。 12345678910class Person &#123; static getName() &#123; console.log('hello'); &#125;&#125;Person.getName(); // hellolet p = new Person();p.getName(); // p.getName is not a function Person类的getName方法前面有一个static关键字，表明该方法是一个静态方法; 该方法只能在Person类来调用，不能在实例上调用; 123456789101112class Person &#123; static getName() &#123; console.log('hello'); // 静态方法里的this代表当前类，可以调用其他静态方法 this.getAge(); &#125; static getAge() &#123; console.log('age'); &#125;&#125;Person.getName(); // hello age 如果静态方法里面包含this关键字，则this指向的是类，而不是实例。 父类的静态方法可以被继承： 1234567891011class Person &#123; static getName() &#123; console.log('parent hello'); &#125;&#125;class Child extends Person &#123;&#125;Child.getName(); // parent hello 子类可以继承父类的静态方法，如上面代码，子类Child继承父类Person的getName静态方法，并且调用; 1234567891011121314class Person &#123; static getName() &#123; console.log('parent hello'); &#125;&#125;class Child extends Person &#123; static getChildName() &#123; // 通过super对象调用父类的静态方法 super.getName(); &#125;&#125;Child.getChildName(); // parent hello 静态方法也可以通过super对象来调用; 七、类的静态属性静态属性指的是class本身的属性，即class.PropName,而不是定义在实例对象上的属性。 方式一：老写法 12345class Person &#123;&#125;Person.prop = 'tom';Person.prop; // tom 方式二：新写法 1234class Person &#123; static prop = 'tom';&#125;Person.prop; 八、实例属性新写法：实例属性除了可以写在constructor方法里面，还可以写在类的最顶层。 1234567891011// 老写法class Person &#123; constructor (age) &#123; this.age = 20 &#125;&#125;// 新写法class Person &#123; age = 20;&#125; 九、extends继承的基本用法123456class Person &#123; &#125;class Child extends Person &#123;&#125; Child 通过extends继承了父类Person的所有属性和方法; 12345678910class Person &#123;&#125;class Child extends Person &#123; constructor() &#123; &#125;&#125;let c = new Child(); // Must call super constructor in derived class before accessing 'this' or returning from derived constructor 子类必须在constructor方法中调用super方法，否则会报错； es6的继承机制是先将父类的实例对象的属性和方法，加到this上(所以必须先调用super方法)；然后在再子类的构造函数修改this； 12345678910111213141516class Person &#123;&#125;class Child extends Person &#123; &#125;// 等同于class Person &#123;&#125;class Child extends Person &#123; constructor(...args) &#123; super(...args) &#125;&#125; 如果子类没有constructor方法，这个方法会被默认添加，并且同时会在构造函数中调用super方法，也就是说，不管有没有显示定义，任何一个子类都有constructor方法。 12345678910111213141516class Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125;&#125;class Child extends Person &#123; constructor(name,age,gender) &#123; // this.gender = gender; // Must call super constructor in derived class before accessing 'this' or returning from derived constructor super(name,age); this.gender = gender; // 正确 &#125;&#125;let c = new Child('tom',20,'男'); 注意：只有在子类的构造函数中，只有调用super之后，才可以使用this关键字； 上面的代码中，由于在子类的constructor方法中没有调用super关键字，就使用this关键字会报错，而放在super之后就是正确的。 十、super关键字super关键字既可以当作函数使用，也可以当作对象使用。 super作为函数调用，代表父类的构造函数，es6要求，子类的构造函数必须执行一次super函数。super虽然代表父类的构造函数，但是返回的却是子类的实例，即super内部的this执向的是子类的实例。作为函数时，super()只能用在子类的构造函数中，用在其他地方会报错。 super作为对象是，在普通方法中，代表父类的原型对象，在静态方法中，执向父类。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js对象和原型链]]></title>
    <url>%2F2019%2F01%2F06%2Fjs%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[js对象和原型链一、创建对象的几种方式 对象直接量： 12var o1 = &#123; name : 'tom'&#125;;var o2 = new Object(&#123; name : 'jack' &#125;); 构造函数： 12345function Person (name,age) &#123; this.name = name; this.age = age;&#125;var p = new Person('rose',28); Object.create()方式： 12var p = &#123; name : 'john'&#125;;var p1 = Object.create(p); 二、new做了哪些事?1. 新建一个对象； 2. 修改新建对象的原型对象为构造函数的原型对象； 3. 修改this的指向； 4. 返回新建对象。 123456789101112131415161718192021222324252627282930313233343536/* * 1. 新建一个对象 * 2. 修改新建对象的prototype指向构造函数的prototype * 3. 修改this的指向 * 4. 返回新建对象（如果构造函数没有返回值）*/function new2 (callback) &#123; // 1.新建一个对象 // 2. 修改新建对象的prototype指向构造函数的prototype let obj = Object.create(callback.prototype); /* * 或者 var obj=&#123;&#125;; obj.__proto__= callback.prototype; */ // 修改this的指向为新建对象obj let result = callback.call(obj); // 返回新建对象 if(typeof result === 'object') &#123; // 如果构造函数有返回值，并且是对象，则返回这个对象 return result; &#125;else &#123; // 否则返回新建的对象 return obj; &#125;&#125;function P () &#123; this.name = "name";&#125;var p1 = new2(P) 注意：call、apply、bind的简单区别： 1. call、apply都是立即执行函数，bind是返回一个新的函数，他们三个的作用都是为了改变this的指向,第一个参数都是this要指向的对象； 2. call和bind的第一个参数可以跟很多个参数，而apply的第二个参数是一个数组。 三、构造函数、原型、实例之间的关系：每个构造函数都有一个原型对象，原型对象都有一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。------《JavaScript高级程序设计》 123456789function Person (name,age) &#123; this.name = name; this.age = age;&#125;var p = new Person('tom',22);console.log(p);console.log(p.__proto__ === Person.prototype);console.log(p.constructor);console.log(p.__proto__.constructor === Person.prototype.constructor); 他们之间的关系如下图： 四、对象的继承： 对象的继承一：借助构造函数实现继承 12345678910111213141516171819202122function Parent_1 (name,age) &#123; this.name = name; this.age = age;&#125;Parent_1.prototype.say = function () &#123; console.log('parent say hello');&#125;function Child_1 (naem,age,gender) &#123; // 借助构造函数实现继承的关键代码 // 通过在子类里调用父类构造函数，并且改变this的指向实现继承 Parent_1.call(this,name,age); this.gender = gender;&#125;var c1 = new Child_1('jack',20,'男');c1.say() // Uncaught TypeError: c1.say is not a function 借助构造函数实现继承的关键代码的就是Parent_1.call(this,name,age),通过在子类构造函数中调用父类的构造函数并且修改this的执行来实现继承。 缺点：可以实现继承，但是只能继承父类构造函数的属性和方法，不能继承父类原型链上的方法和属性. 对象的继承二：原型链继承 123456789101112131415161718192021function Parent_2 (name,age) &#123; this.name = 'parent name'; this.age = 20;&#125;Parent_2.prototype.say = function () &#123; console.log('parent say hello');&#125;function Child_2 (gender) &#123; this.gender = gender;&#125;// 借助原型链继承的关键代码// 修改子类构造函数的原型修改为父类父类的实例，这样子类实例就可以通过原型链，继承父类构造函数中的属性和方法，而且也可以继承父类构造函数原型中的属性和方法Child_2.prototype = new Parent_2();var c2 = new Child_2('男')c2.say() // parent say hello 123456789101112131415161718192021222324function Parent_2 (name,age) &#123; this.name = 'parent name'; this.age = 20; this.data = [1,2,3];&#125;Parent_2.prototype.say = function () &#123; console.log('parent say hello');&#125;function Child_2 (gender) &#123; this.gender = gender;&#125;// 修改子类构造函数的原型修改为父类构造函数的实例Child_2.prototype = new Parent_2();var c2 = new Child_2('男')var c3 = new Child_2('男')c2.say() // parent say helloc2.data.push(4);console.log(c2.data); // [1, 2, 3, 4]console.log(c3.data); // [1, 2, 3, 4] 原型链继承的关键代码就是Child_2.prototype = new Parent_2(),通过修改子类构造函数的原型链为父类实例，这样在访问子类实例的时候，子类实例会通过原型链访问到父类实例中的属性和方法，而且还会通过原型链来继承父类构造函数原型对象中的属性和方法。 缺点：通过原型链可以解决通过构造函数实现继承中的缺点，不仅可以继承父类构造函数中的属性和方法，而且还可以继承父类原型对象中的属性和方法，但是如过父类构造函数中的属性为引用类型的时候，通过修改一个实例属性的时候，会影响到其他实例。 对象的继承三：组合继承 123456789101112131415161718192021222324252627282930function Parent_3 () &#123; this.name = 'parent'; this.data = [1,2,3];&#125;Parent_3.prototype.say = function () &#123; console.log('hello word');&#125;function Child_3 (gender) &#123; // 通过构造函数来继承父类构造函数中的属性和方法 Parent_3.call(this); this.gender = '男';&#125;// 通过修改子类构造函数的原型为父类构造函数实例来继承父类构造函数的属性和方法，以及继承父类构造函数原型对象上的属性和方法Child_3.prototype = new Parent_3();var c4 = new Child_3();var c5 = new Child_3();console.log(c4.constructor === Child_3 ) // falsec4.data.push(4);console.log(c4.data); // [1, 2, 3, 4]console.log(c5.data); // [1, 2, 3]console.log(c4.say()); // hello wordconsole.log(c5.say()); // hello word 缺点：在上面的组合继承中，在代码`Child_3.prototype = new Parent_3()`和`Child_3.prototype = new Parent_3()`中Parent_3()执行了两次，还可以对其进行优化。`console.log(c4.constructor === Child_3 )`的执行结果为`false`，说明我们修改了`Child_3.prototype`中constructor的指向，这不是我们所希望看到的。 组合继承的优化一: 123456789101112131415161718192021222324252627282930function Parent_3 () &#123; this.name = 'parent'; this.data = [1,2,3];&#125;Parent_3.prototype.say = function () &#123; console.log('hello word');&#125;function Child_3 (gender) &#123; // 通过构造函数来继承父类构造函数中的属性和方法 Parent_3.call(this); this.gender = '男';&#125;// 通过修改子类构造函数的原型为父类构造函数的原型Child_3.prototype = Parent_3.prototype;var c4 = new Child_3();var c5 = new Child_3();console.log(c4.constructor === Child_3 ) // falsec4.data.push(4);console.log(c4.data); // [1, 2, 3, 4]console.log(c5.data); // [1, 2, 3]console.log(c4.say()); // hello wordconsole.log(c5.say()); // hello word 在上面的代码中通过Child_3.prototype = Parent_3.prototype来解决Parent_3执行两次的问题。 组合继承的优化二: 12345678910111213141516171819202122232425262728293031function Parent_3 () &#123; this.name = 'parent'; this.data = [1,2,3];&#125;Parent_3.prototype.say = function () &#123; console.log('hello word');&#125;function Child_3 (gender) &#123; // 通过构造函数来继承父类构造函数中的属性和方法 Parent_3.call(this); this.gender = '男';&#125;// 通过修改子类构造函数的原型为父类构造函数的原型Child_3.prototype = Parent_3.prototype;Child_3.prototype.constructor = Child_3var c4 = new Child_3();var c5 = new Child_3();console.log(c4.constructor === Child_3 ) // truec4.data.push(4);console.log(c4.data); // [1, 2, 3, 4]console.log(c5.data); // [1, 2, 3]console.log(c4.say()); // hello wordconsole.log(c5.say()); // hello word 在上面代码中通过Child_3.prototype.constructor = Child_3来解决Child_3.prototype`中constructor的指向问题。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css盒模型]]></title>
    <url>%2F2019%2F01%2F05%2Fcss%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[css盒模型一、css盒模型分类：css盒模型分为IE盒模型和标准盒模型，以下是IE盒模型和标准盒模型的对比 分类 区别 box-sizing IE盒模型 content包含padding和border border-box 标准盒模型 content不包含padding和border content-box 二、js如何获取到盒模型的宽度和高度？以下是三种获取dom节点盒模型宽度和高度的方法以及他们的优缺点 方式 优点 缺点 dom.style.width/height 略 只能获取到内联样式的宽度和高度 dom.current.style.width/height 可以获取到当前dom节点的宽度和高度、无论是内联还是外部链接样式 只有IE浏览器支持 window.getComputedStyle(dom).width/height 兼容性比较好，可以获取到当前dom节点的宽度和高度，无论是内联还是外部链接样式 略 三、BFC BFC定义 BFC(Block formatting context)块级格式化上下文。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC的布局规则 内部的box会在垂直方向上一个接一个的放置； BFC在页面上是一个独立的容器，不会影响到外部元素也不会被外部元素影响到； BFC计算高度时，浮动元素也参与在内； BFC区域不会与浮动元素发生重叠(通常可以用来清除浮动)； 属于同一个BFC的两个相邻box的margin会发生重叠； 如何生成BFC？ overflow不为visible； float为left、right； position为absolute、fixed； display为inline-block、table、table-cell、flex等； BFC的应用 应用一：解决属于同一个BFC内相邻的box发生margin重叠问题 1.外边距重叠情况 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .container &#123; border: 1px solid #fff; width: 200px; height: 200px; background: pink; &#125; .children_1,.children_2 &#123; height: 50px; line-height: 50px; width: 50px; text-align: center; margin: 20px; &#125; .children_1 &#123; border: 1px solid red; &#125; .children_2 &#123; border: 1px solid blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="children_1"&gt;box1&lt;/div&gt; &lt;div class="children_2"&gt;box2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如图: 2.解决方案: 在每一个子元素的外层添加一个父元素，并且让父元素生成一个BFC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .container &#123; border: 1px solid #fff; width: 200px; height: 200px; background: pink; &#125; .children_1,.children_2 &#123; height: 50px; line-height: 50px; width: 50px; text-align: center; margin: 20px; &#125; .children_1 &#123; border: 1px solid red; &#125; .children_2 &#123; border: 1px solid blue; &#125; .bfc_container &#123; display: table; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="bfc_container"&gt; &lt;div class="children_1"&gt;box1&lt;/div&gt; &lt;/div&gt; &lt;div class="bfc_container"&gt; &lt;div class="children_2"&gt;box2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如图： 应用二：页面两栏布局，左侧浮动且宽度固定，右侧生成BFC，宽度自适应 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .left &#123; float: left; width: 200px; height: 100px; background-color: red; &#125; .right &#123; height: 100px; overflow: hidden; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;左侧浮动、固定宽度&lt;/div&gt; &lt;div class="right"&gt;右侧生成BFC自适应&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如图： 3.清除浮动: 子元素浮动后，父元素高度为0，可以通过把父元素生成一个BF来解决(BFC计算高度时，浮动元素也参与在内) 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .container &#123; overflow: hidden; &#125; .left &#123; float: left; width: 200px; height: 100px; line-height: 100px; text-align: center; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;子元素浮动&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如图：]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM事件]]></title>
    <url>%2F2019%2F01%2F04%2FDOM%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[DOM事件类一、基本概念：DOM事件级别 DOM事件级别 DOM事件 描述 DOM0 element.onclick=function(){} DOM0时代制定的DOM事件标准 DOM2 element.addEventListener(‘click’,function(){ },false) ①DOM2时代制定的事件监听；②DOM1没有制定与事件相关的；③false,默认表示冒泡阶段触发，true表示捕获阶段 DOM3 element.addEventListener(‘keyup’,function(){ },false) DOM3在DOM2的基础上增加了一些鼠标键盘事件 二、DOM事件模型（冒泡、捕获） 事件冒泡：是由IE团队提出来的，即事件是由最具体的那个元素j接收，然后逐级向上传播 事件捕获： 事件捕获是由NetSpace团队提出来的，是由最上一级节点先接收事件，然后向下传播到具体的节点 三、DOM事件流“DOM2级事件”规定了事件l流包含3个阶段，事件捕获阶段，目标阶段和事件冒泡阶段。首先发生的事件捕获阶段，然后实际的目标接收到事件，最后阶段是冒泡阶段。 四、DOM事件捕获的具体流程window -&gt; document(文档对象) -&gt; html -&gt; body -&gt; div(具体目标元素) 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;DOM事件捕获流程&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 所有的addEventListener最后一个参数是true，表示在捕获阶段，不加默认为false，在冒泡阶段触发 // window window.addEventListener('click',function() &#123; console.log('window') &#125;,true) // document document.addEventListener('click',function () &#123; console.log('document') &#125;,true) // html document.documentElement.addEventListener('click',function()&#123; console.log('html') &#125;,true) // body document.body.addEventListener('click',function()&#123; console.log('body') &#125;,true) // div let btn = document.getElementById("btn"); btn.addEventListener('click',function () &#123; console.log('div') &#125;,true) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 五、DOM事件冒泡的具体流程div(具体目标元素) -&gt; body -&gt; html -&gt; document(文档对象) -&gt; window 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;DOM事件冒泡流程&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // window window.addEventListener('click', function () &#123; console.log('window') &#125;, false) // document document.addEventListener('click', function () &#123; console.log('document') &#125;, false) // html document.documentElement.addEventListener('click', function () &#123; console.log('html') &#125;, false) // body document.body.addEventListener('click', function () &#123; console.log('body') &#125;, false) // div let btn = document.getElementById("btn"); btn.addEventListener('click', function () &#123; console.log('div') &#125;, false) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、Event对象的具体应用 事件对象 描述 event.preventDefault() 阻止默认事件 event.stopPropagation() 阻止冒泡 event.currentTarget() 当前绑定事件对象的元素 event.target() 当前被点击的元素 七、自定义事件 自定义不带参数事件 12345let ev = new Event('cat');document.addEventListener('cat',function() &#123; console.log('自定义不带参数事件');&#125;)document.dispatchEvent(ev); 自定义可以传参事件 1234567let ev = new CustomEvent('dog',&#123; detail: &#123; a : '参数a'&#125;&#125;);document.addEventListener('dog',function(e) &#123; console.log('自定义事件参数为',e.detail);&#125;)document.dispatchEvent(ev); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;自定义事件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;按钮1&lt;/button&gt; &lt;button id="btn2"&gt;按钮2&lt;/button&gt; &lt;/div&gt; &lt;script&gt; &#123; // 一、 自定义一个不可传参事件 // new 一个custon事件对象，事件名为custom let event = new Event('custom'); // 监听自定义事件 document.addEventListener('custom', function () &#123; console.log('自定义事件') &#125;) let btn = document.getElementById('btn'); btn.addEventListener('click', function () &#123; console.log('click事件'); // 触发自定义事件 document.dispatchEvent(event); &#125;) &#125; &lt;/script&gt; &lt;script&gt; &#123; // 自定义一个传参事件 // new 一个自定义事件对象，并且传递参数 /* * bubbles : 是否冒泡 * cancelable ： 是否可取消该事件 * detail : 需要传递的事件参数 */ let event_2 = new CustomEvent('customEvent', &#123; bubbles: 'true', cancelable: 'true', detail : &#123; a: '参数a', b: '参数b' &#125;&#125; ); // 监听自定义事件 document.addEventListener('customEvent', function (e) &#123; console.log('自定义事件,参数为:', e); &#125;) let btn_2 = document.getElementById("btn2"); btn_2.addEventListener('click',function()&#123; console.log('clcik事件2'); document.dispatchEvent(event_2); &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两栏布局（左侧固定，右侧自适应）]]></title>
    <url>%2F2018%2F12%2F19%2F%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[css实现左侧宽度固定，右侧自适应布局的四种方法1. 左侧浮动，右侧生成BFC123456789&lt;div className = &#123; style['float-left-center'] &#125;&gt; &lt;div className=&#123; style.left &#125;&gt;&lt;/div&gt; &lt;div className=&#123; style.right &#125;&gt; &lt;p&gt;左侧浮动的两栏内容&lt;/p&gt; &lt;p&gt;左侧浮动的两栏内容&lt;/p&gt; &lt;p&gt;左侧浮动的两栏内容&lt;/p&gt; &lt;p&gt;左侧浮动的两栏内容&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 1234567891011121314151617// 左侧浮动，右侧生成BFC.float-left-center &#123; margin: 5px 0; width: 100%; color: blue; .left &#123; float: left; width: 300px;; height: 100px; background: red; &#125; .right &#123; background: #eee; //height: 100px; overflow: auto; &#125;&#125; 2. flex布局实现12345678910&lt;div className=&#123; style['flex-left-center']&#125;&gt; &lt;div className=&#123; style.left &#125;&gt;&lt;/div&gt; &lt;div className=&#123; style.right &#125;&gt; &lt;p&gt;flex布局，左侧固定&lt;/p&gt; &lt;p&gt;flex布局，左侧固定&lt;/p&gt; &lt;p&gt;flex布局，左侧固定&lt;/p&gt; &lt;p&gt;flex布局，左侧固定&lt;/p&gt; &lt;p&gt;flex布局，左侧固定&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314/*flex布局实现*/.flex-left-center &#123; display: flex; margin: 5px 0; .left &#123; width: 300px; height: 100px; background: red; &#125; .right&#123; flex: 1; background: #eee; &#125;&#125; 3. css3 网格布局12345678910&lt;div className=&#123; style[&apos;grid-left-center&apos;]&#125;&gt; &lt;div className=&#123; style.left &#125;&gt;&lt;/div&gt; &lt;div className=&#123; style.right &#125;&gt; &lt;p&gt;网格布局实现&lt;/p&gt; &lt;p&gt;网格布局实现&lt;/p&gt; &lt;p&gt;网格布局实现&lt;/p&gt; &lt;p&gt;网格布局实现&lt;/p&gt; &lt;p&gt;网格布局实现&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314// 网格布局.grid-left-center &#123; margin: 5px 0; display: grid; grid-template-columns: 300px auto; grid-template-rows: 200px auto; .left &#123; background: red; &#125; .right &#123; background: #eee; &#125;&#125; 4. 绝对定位实现12345678910&lt;div className=&#123; style['absoulte-left-center']&#125;&gt; &lt;div className=&#123; style.left &#125;&gt;&lt;/div&gt; &lt;div className=&#123; style.right &#125;&gt; &lt;p&gt;绝对定位实现&lt;/p&gt; &lt;p&gt;绝对定位实现&lt;/p&gt; &lt;p&gt;绝对定位实现&lt;/p&gt; &lt;p&gt;绝对定位实现&lt;/p&gt; &lt;p&gt;绝对定位实现&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617// 绝对定位实现.absoulte-left-center &#123; position: relative; margin: 5px 0; .left &#123; position: absolute; width: 300px; height: 100px; background: red; &#125; .right &#123; position: absolute; left: 300px; right: 0; background: #eee; &#125;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
</search>
