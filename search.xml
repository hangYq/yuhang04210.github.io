<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序开发总结]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[微信小程序开发总结一、 实现页面向上滑动或者向下滑动时按钮隐藏，当滑动停止的时候，按钮出现1234567891011121314151617181920212223242526272829303132&lt;view :class="!isShowWriteBtn ? 'hide_page_bottom' : '' " class="page_bottom" @click="writeWineComment"&gt; &lt;view class="write_wine_comment"&gt;写酒评&lt;/view&gt;&lt;/view&gt;&lt;style&gt; /* 写酒评 */ .page_bottom &#123; position: fixed; bottom: 70upx; left: 50%; margin-left: -90upx; width: 180upx; height: 80upx; line-height: 80upx; text-align: center; background: #ffc91f; border-radius: 36upx; box-shadow: 0 5upx 20upx #ffc91f; transition: all 0.6s ease-in-out; &#125; .hide_page_bottom &#123; bottom: -80upx; &#125; .write_wine_comment &#123; font-size: 30upx; font-weight: 500; color: rgba(51, 51, 51, 1); &#125;&lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849export default &#123; data() &#123; return &#123; scrollTop: 0, // 页面滑动后距离顶部的距离 isShowWriteBtn: true // 是否显示底部写酒评按钮 &#125;; &#125;, onPageScroll(ev) &#123; this.handWriteBtn(ev); &#125;, methods: &#123; // 处理滑动时底部发酒评按钮显示隐藏 handWriteBtn(ev) &#123; let that = this; //当滚动的top值最大或最小时，为什么要做这一步是因为在手机实测小程序的时候会发生滚动条回弹，所以为了处理回弹，设置默认最大最小值 if (ev.scrollTop &lt;= 0) &#123; ev.scrollTop = 0; &#125; else if (ev.scrollTop &gt; uni.getSystemInfoSync().windowHeight) &#123; ev.scrollTop = uni.getSystemInfoSync().windowHeight; &#125; //判断浏览器滚动条上下滚动 if ( ev.scrollTop &gt; this.scrollTop || ev.scrollTop == uni.getSystemInfoSync().windowHeight ) &#123; //向下滚动 that.isShowWriteBtn = false; &#125; else &#123; //向上滚动 that.isShowWriteBtn = false; &#125; //给scrollTop重新赋值 setTimeout(() =&gt; &#123; that.scrollTop = ev.scrollTop; setTimeout(() =&gt; &#123; // 如果当前的scrollTop和滚动的scrollTop值相同时，表示你滑动已经停止 if (ev.scrollTop == that.scrollTop) &#123; that.isShowWriteBtn = true; &#125; &#125;, 300); &#125;); &#125;, // 写酒评 writeWineComment() &#123; // 处理函数逻辑 //this.isShowCommentModal = true; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redux简要总结]]></title>
    <url>%2F2019%2F02%2F27%2Fredux%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[redux简要总结一、redux的核心概念： store action reducer store : 记录所有的状态，state action : action本质是一个对象，告诉dispath需要做什么 reducer ： reducer拿到state和action，生成新的state(根据老的状态和action来生成新的状态) 二、redux的简单使用： 首先通过reducer新建store，可以随时通过store.getState获取状态 需要更新状态的时候，store.dispatch(action)来修改状态 reducer函数接受state和action，返回新的state，可以通过store.subscrible来监听每次修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; createStore &#125; from "redux";import &#123; StringDecoder &#125; from "string_decoder";// 1. 新建reducerfunction todo (state = 10,action) &#123; switch (action.type) &#123; case 'add': return state + 1; break; case 'minus': return state - 1; break; default: return 10; break; &#125;&#125;// 2. 使用createStore(reucer),传入一个reducer来新建一个store，并且可以使用store.getState()来获取到最新的statelet store = createStore(todo);let init = store.getState();console.log(init);// 3.通过dispatch触发一个action来修改state，并且再次通过store.getState()来获取到最新的statestore.dispatch(&#123; type : 'add'&#125;)let num = store.getState();console.log(num)// 4. 这里我们也可以使用store.subscribe()来添加一个变化监听器，每当dispatch一个action的时候，state就可能已发生变化，我们就可以在回调函数里监听state的变化。function listener () &#123; let current = store.getState(); console.log('当前数值为',current);&#125;store.subscribe(listener);// 5. 此时再次触发一个action，通过stroe.subscribe()方法来监听state的变化store.dispatch(&#123; type: 'minus'&#125;) 如图:]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[letCode算法题-数组]]></title>
    <url>%2F2019%2F02%2F24%2FletCode%E7%AE%97%E6%B3%95%E9%A2%98-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[letCode算法题-数组给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 1234567891011121314151617181920212223242526272829303132333435363738var letterCombinations = function (digits) &#123; // 建立电话号码映射关系 let map = ['','','abc','def','ghi','jkl','mno','pqrs','tuv','wxyz']; // 把输入的数值变为数组 let nums = digits.split(''); let code = nums.map(item =&gt; &#123; return map[item] &#125;); // 递归 let fun = (arr) =&gt; &#123; // 临时变量用来保存前两个组合的结果 let result = []; // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素 for (let i = 0; i &lt; arr[0].length; i++) &#123; for (let j = 0; j &lt; arr[1].length; j++) &#123; result.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`); &#125; &#125; // 用前两个组合的结果用来替换前两个元素 arr.splice(0, 2, result); if (arr.length &gt; 1) &#123; fun(arr); &#125; else &#123; return result; &#125; &#125; return fun(code);&#125;; 提示： 此题解题思路需要考虑，如果有多于两个数字时，应该先考虑把前两个数字结合，然后再两两结合。 本题主要是用到了数组splice()方法，以及递归调用。 如图：]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[letCode算法题-字符串]]></title>
    <url>%2F2019%2F02%2F23%2FletCode%E7%AE%97%E6%B3%95%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[letCode算法题-字符串题目一：描述： 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 输入: “Let’s take LeetCode contest” 输出: “s’teL ekat edoCteeL tsetnoc” 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 解法一：12345678910var reverseWords = function(s) &#123; let arr = s.split(" "); let result = arr.map(item =&gt; &#123; return item.split('').reverse().join(''); &#125;); return result.join(' ');&#125;; 对于上面的代码我们还可以对其进行优化，使代码看起来更加优雅。 12345var reverseWords = function(s) &#123; return s.split(' ').map( item =&gt; &#123; return item.split("").reverse().join(""); &#125;).join(" ")&#125;; 提示： 这里使用了字符串split方法，split方法可以把一个字符串分割为一个数组,如果把””作为separator分割符，那么会把字符串每一个字符都进行分割。当然separator也开始以是一个正则表达式。 更多详情可以参照菜鸟教程split方法 1string.split(separator,limit) 解法二：提示： 此种解法使用字符串split方法用正则来匹配空格单词分割 12345var reverseWords = function(s) &#123; return s.split(/\s/g).map(item =&gt; &#123; return item.split('').reverse().join(''); &#125;).join(" ");&#125;; 解法三：12345var reverseWords = function(s) &#123; return s.match(/[\w']+/g).map( item =&gt; &#123; return item.split("").reverse().join(""); &#125;).join(" ")&#125;; 提示： 这里使用了字符串的match方法，可以用来匹配每个单词进行分割。 1string.match(regexp) 参数： 参数 描述 regexp 必需，规定要匹配的RegExp对象，如果该参数不是RegExp对象，可以使用RegExp将其转化为RegExp对象 返回值： 返回值为一个数组，用来存放匹配到的结果，,如果没有找到则返回null。 1. 更多详情可以参考菜鸟教程match 2. 菜鸟教程JavaScript RegExp 对象 3. 菜鸟教程RegExp参考手册 题目二：给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例 1 : 输入: “00110011” 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 请注意，一些重复出现的子串要计算它们出现的次数。 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 解法： 12345678910111213141516171819202122232425262728293031function f(str) &#123; let result = []; let match = (s) =&gt; &#123; // 匹配连续多个0或者多个1，并且取第一个 let j = s.match(/(0+|1+)/)[0]; // 如果取到的是0，就进行取反，然后获取长度和j一样 let o = (j[0] ^ 1).toString().repeat(j.length); let reg = new RegExp(`^($&#123;j&#125;$&#123;o&#125;)`); // 如果在子字符串中可以找到匹配的，则返回，否则返回空字符串 if(reg.test(s)) &#123; return RegExp.$1; &#125;else &#123; return ''; &#125; &#125; for(let i = 0; i &lt; str.length - 1; i++) &#123; // 从 i 开始截取到最后一个 let sub = match(str.slice(i)); if(sub) &#123; result.push(sub); &#125; &#125; return result;&#125; 提示1：这里使用到了test()方法： test()方法搜索字符串指定的值，根据结果并返回真或假。 下面的示例是从字符串中搜索字符 “e” ： 实例 var patt1=new RegExp(“e”); document.write(patt1.test(“The best things in life are free”)); 由于该字符串中存在字母 “e”，以上代码的输出将是：true 提示2：这里使用到了字符串的repeat方法，repeat() 方法字符串复制指定次数。 1string.repeat(count)]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面试题总结(二)]]></title>
    <url>%2F2019%2F02%2F22%2FJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[JavaScript面试题总结(二)一、题目一：描述：1. 获取某个页面所使用的所有标签 2. 并且统计出现次数最多的标签 第一步先获取所有的标签，并将类数组对象转化为数组，统计每一种标签出现的次数 123456789101112/** * 获取所有的标签节点，并且对每一种标签进行统计个数，返回一个对象 */function getAllTags () &#123; let nodeList = document.querySelectorAll("*"); obj = Array.from(nodeList).reduce((pre,next) =&gt; &#123; pre[next.localName] = pre[next.localName] ? ++pre[next.localName] : 1; return pre; &#125;,&#123;&#125;); return obj;&#125; 注意：1. document.querySelectorAll(&quot;*&quot;)可以获取所有的节点对象，这里的返回结果为类数组对象; 2. Array.from()可以把一个类数组对象转化为一个数组； 3. pre[next.localName] = pre[next.localName] ? ++pre，这里要注意的是，返回的类数组对象的每一项也都是一个对象，相同的节点有不同的类名也会归为一个不同项，我们可以通过判断localName来判断是否是相同的标签。 如图： 统计出现次数最多的标签 123456789101112131415function getMaxCount(obj) &#123; let result = &#123; count: 0, tag : '' &#125;; Object.keys(obj).forEach(item =&gt; &#123; if (result.count &lt; obj[item]) &#123; result.count = obj[item]; result.tag = item; &#125; &#125;) return result;&#125; 123456function getResult () &#123; let obj = getAllTags(); let result = getMaxCount(obj); return result;&#125; 上面的代码虽然解决此题，但是还有一个问题，如果有两个或者多个标签出现的次数相同并且次数最多，上面的代码并不能获取正确的结果，我们仍然需要进行改进,我们可以把getMaxCount方法进行改造。 我们可以在原有基础上，把result对象tag改变为tag数组，用来存放所有的标签，用tempTags来临时存放出现次数相同的标签。如果result.count &lt; obj[item],需要注意的是，要把tempTags临时数组清空，因为此时已经有出现次数更多的标签出现。 1234567891011121314151617181920212223242526272829303132333435363738/** * * @param &#123;object&#125; obj 要传入的类数组对象 * 返回一个对象 */function getMaxCount (obj) &#123; // 临时存储个数相同的标签 tempTags = []; /** * count : 标签个数 * tags : 出现次数相同的标签 */ let result = &#123; count : 0, tags : [] &#125;; Object.keys(obj).forEach( item =&gt; &#123; if(result.count &lt; obj[item]) &#123; result.count = obj[item]; result.tags[0] = item; // 如果有出现次数更多的标签，把临时数组置为空 tempTags = []; &#125; else if (result.count === obj[item]) &#123; tempTags.push(item); &#125; &#125;) if(tempTags.length &gt; 0) &#123; tempTags.forEach(item =&gt; &#123; result.tags.push(item); &#125;) &#125; return result;&#125; 如图： 二、题目二：描述：有A、B、C三个请求，C依赖于A和B连个请求，如何实现？ 12345678910111213141516171819202122232425let getA = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 3000);&#125;)let getB = new Promise((reolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reolve(3); &#125;, 1000);&#125;)function getC(a, b) &#123; return a + b;&#125;Promise.all([getA, getB]).then(data =&gt; &#123; console.log(data); return getC(data[0],data[1]);&#125;).then(res =&gt; &#123; console.log('res',res); // 5&#125;) 这里可以使用promise.all()来并行实现，用来提高效率。当然也可以使用async来实现，不过async是同步来执行的，可能会有一定的效率问题。 本题参考资料：1. es6中的promise.all使用问题 2. ES6 Promise 并行执行和顺序执行 3. 阮一峰es6中promise.all的使用 三、写出下列输出123456789101112var a = &#123; value : 1, func1: function () &#123; console.log(this.value) &#125;, func : () =&gt; &#123; console.log(this.value); &#125;&#125;a.func1(); // 1 a.func(); // undefined 这里主要考察了es6中的箭头函数。在a对象中，func1是一个普通函数，func是一个箭头函数，由于箭头函数使得this由动态变成静态，当我们调用a.func1()的时候this指向的为a,输出为1；在调用a.func()的时候，由于func()是一个箭头函数，使得this指向了全局对象window，window中没有value值，所以输出结果为undefined。 如果我们在全局对象中添加一个变量var value = 3，则输出结果就为3。代码如下： 1234567891011121314var a = &#123; value : 1, func1: function () &#123; console.log(this.value) &#125;, func : () =&gt; &#123; console.log(this.value); &#125;&#125;var value = 3;a.func1(); // 1 a.func(); // 3]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js模块化]]></title>
    <url>%2F2019%2F02%2F21%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[js模块化一、CommonJsnode.js的出现标志着”javaScript模块化编程”的正式诞生。因为老实说，在浏览器环境下，没有模块化并没有什么太大的影响，毕竟网页应用程序的复杂性有限。但是在服务端，一定要有模块化，与操作系统和其他应用程序互动，否则根本没法编程。Node.js是CommonJs规范的实现，webpack也是CommonJs规范的实现。 1. CommonJs定义的模块分为：① 模块引用：require，require用来引入外部模块（`require是同步的`） ② 模块定义：exports，exports对象用来导出当前模块的方法和变量，唯一的导出口 ③ 模块表示： module，module对象就代表模块本身 2. 浏览器不兼容CommonJs的原因：浏览器不兼容CommonJs的根本原因，在与浏览器缺少四个node.js环境的变量： module exports require global 注意： 只要能够提这四个变量，浏览器就可以加载CommonJs模块。 二、AMD1. AMD的出现基于CommonJs的node.js出来以后，服务端的模块概念已经形成，很自然大家就想要客户端模块。而且最好两者可以兼容，一个模块不用修改，在服务端和浏览器都可以运行。但是有一个很大的局限，使得CommonJs规范不适用于浏览器。 12const math = require('math');math.add(1,2); 第二行math.add(1,2)必须在第一行require加载完成后，才可以执行，也就是说如果加载时间很长，浏览器就会在哪里等待，因为在CommonJs中require是同步的。 上面的问题对于服务端不是一个问题，因为所有的文件都存放在本地硬盘里，可以同步加载完成，等待的时间就是硬盘的读取时间。但是对于浏览器而言，是一个大的问题，因为所有的文件都是放在服务器，等待的时间取决于网络，可能需要等待的时间比较久，浏览器处于假死状态。 因此浏览器的模块不能采用同步加载，只能使用异步方式。这就是AMD诞生的背景。 CommonJs的实现是为了后端实现而制定的，它不适合前端，AND(异步模块定义)的出现就是为了前端实现而制定的规范。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用的是异步方式加载模块，模块的加载不影响它后面的语句的执行，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成后，才会调用这些语句。 AMD的实现也是采用require来实现的，但是不同于CommonJs，它有两个参数： 1require([module],callback); 第一个参数[module],是一个数组，就是要加载的模块；第二个参数callback，就是加载成功之后的回调函数。如果将前面的代码改成AMD的形式，就是下面这样： 123require(['math'],function(math) &#123; math.add(1,2);&#125;) math.add()与math加载不是同步的，浏览器不会发生假死，所以很显然浏览器比较适合AMD规范。目前require.js就实现了AMD规范。 2. 为什么用require.js?最早的时候，所有的JavaScript代码都放在一个文件下，只要加载这一个文件就够了，后来代码越来越多，一个文件不够用了，必须分为两个文件或者更多文件，一次加载。就出现了这种形式： 1234&lt;script src="a.js"&gt;&lt;/script&gt;&lt;script src="b.js"&gt;&lt;/script&gt;&lt;script src="c.js"&gt;&lt;/script&gt;&lt;script src="d.js"&gt;&lt;/script&gt; 这段代码依次加载多个js文件，不过这样的写法有很大的缺点： 1. 加载的时候，浏览器会停止渲染； 2. 由于js文件之间有一定的依赖性，所以要保持js的先后顺序，否则就会出错。 require.js的出现就是为了解决以上两个问题： 1. 实现js文件的异步加载，避免网页失去响应； 2. 管理模块之间的依赖性，便于代码的编写和维护。 三、CMD大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的。 Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。Sea.js则专注于web端浏览器，同时通过node扩展的方式可以很方便跑在node环境中。 require.js想成为浏览器端的模块加载器，同时也想成为Rhino / Node等环境的模块加载器。 四、 ES6模块化参考阮一峰老师的教程 参考文献 1. js模块化编程之彻底弄懂CommonJS和AMD/CMD！ 2. require.js与Sea.js的异同 3. Javascript模块化编程（一）：模块的写法 4. Javascript模块化编程（二）：AMD规范 5. Javascript模块化编程（三）：require.js的用法 6. 阮一峰ES6 Module的语法]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue双向数据绑定简单实现]]></title>
    <url>%2F2019%2F02%2F15%2Fvue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[vue双向数据绑定简单实现一、Object.defineProperty()Object.defineProperty()允许通过属性描述对象，定义或修改属性，然后返回修改后的对象。 用法：1Object.defineProperty(object, propertyName, attributesObject) Object.defineProperty方法接受三个参数，依次如下。 属性所在的对象 属性名（它应该是一个字符串） 属性描述对象 更过细节可以参考Object.defineProperty() 1234567891011var obj = Object.defineProperty(&#123;&#125;,"name",&#123; get : function() &#123; return 'get'; &#125;, set : function(newValue) &#123; return newValue; &#125;&#125;)obj.name; // getobj.name = 'newName' // newName 二、 实现简易版双向数据绑定使用Object.defineProperty()来定义属性的set函数，属性被赋值的时候，修改Input的value值以及span中的innerHTML；然后监听input的keyup事件，修改对象的属性值，即可实现这样的一个简单的数据双向绑定。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="input"&gt; 输入的内容为：&lt;span id="text-span"&gt;&lt;/span&gt; &lt;script&gt; let input = document.getElementById('input'); let textSpan = document.getElementById('text-span'); let obj = &#123;&#125;; Object.defineProperty(obj,"inputText",&#123; set : function(newValue) &#123; input.value = newValue; textSpan.innerHTML = newValue; &#125; &#125;); input.addEventListener('keyup',function (e) &#123; obj.inputText = e.target.value; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如图：]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript执行机制]]></title>
    <url>%2F2019%2F02%2F14%2FJavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JavaScript执行机制一、关于JavaScript 众所周知，JavaScript在诞生之日就是一门单线程的非阻塞脚本语言。这是由最初的用途来决定的：与浏览器交互。 单线程意味着，JavaScript在执行代码的时候，都只有一个主线程来执行任务。 而非阻塞则是当代码需要进行一项异步任务的时候，主线程会挂起，然后在异步任务返回结果后再根据一定的规则去执行相应的回调函数。 单线程是必要的，也是JavaScript这门语言的基石，因为在浏览器中我们需要各种各样的dom操作。试想一下如果JavaScript是多线程的，那么当两个线程同时去操作同一个dom，例如一个向其添加事件，另外一个删除该dom节点，此时该如何处理，为了保证不会发生类似的事情，JavaScript选择只用一个线程来执行代码，这样就保证了程序执行的一致性。 二、 javascript事件循环JavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。 既然JavaScript是单线程，那么就像只有一个窗口的银行一样，客户需要一个个排队办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务必须排队等着。那么问题来了，如果我们想要浏览一个网页，加载一张很大的图片，难道我们要一直让网页卡着，等待图片加载完才显示吗？因此JavaScript将任务分为两类： 同步任务 异步任务 当我们打开网页的时候，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载音乐、图片、数据请求等就是异步任务。 上图的内容可以用文字来描述: 同步任务和异步任务分别进入不同的场所，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，就会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 三、 setTimeoutsetTimeout在我们的印象中就是异步执行函数，我们经常可以这样使用： 123setTimeout(() =&gt; &#123; console.log('延时3s执行');&#125;,3000); 逐渐setTimeout用的多了，问题也出现了，我们有时候写的是3s后执行，为何有时候要等4s,5s后才会执行： 12345setTimeout(() =&gt; &#123; task();&#125;,3000);console.log('console执行'); 根据前面的结论，setTimeout是异步的，应该先执行console.log()这个同步任务，所以我们的结论是先执行console.log(),然后执行task(); 然后我们修改上面的代码： 12345setTimeout(() =&gt; &#123; task();&#125;,3000);sleep(10000000); 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： setTimeout()进入到Event Table进行注册，计时开始； 执行sleep()函数； 3s到了，计时完成，task()进入到Event Queue(事件队列),但是sleep执行的比较慢，还在执行，task()处于等待执行状态； sleep()执行完成后，task()终于从Event Queue进入了主线程执行; 上述流程走完，我们知道setTimeout这个函数是经过指定时间后，把要执行的任务加入到Event Queue中然后在进入到主线程中执行，又因为js是单线程，任务要一个一个的执行，如果前面的任务还在执行，那么只能等着，导致时间会大于3s。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。 四、 JS的宏任务和微任务除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script &gt; setImmediate &gt; MessageChannel &gt; setTimeout &gt; setInterval micro-task(微任务)：process.nextTick &gt; Promise &gt; MutationObserver 不同的任务会进入到不同的Event Queue,比如setTimeout和setInterval会进入到相同的Event Queue。 事件循环的顺序决定，决定js代码的执行顺序。进入整体代码（宏任务）后，开始第一次循环，接着执行所有的微任务，然后再次从宏任务开始，找到其中一个任务队列执行完毕，在执行所有的微任务。 1234567891011setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise');&#125;).then(function() &#123; console.log('then');&#125;)console.log('console'); 这段代码作为宏任务开始执行; 遇到setTimeout()宏任务，将其回调加入到宏任务Event Queue中; 接下来遇到new Promise，立即执行，然后遇到then函数，将其分发到微任务Event Queue; 遇到console.log，立即执行； 到此，整体script代码作为第一个宏任务已经执行完了，然后去微任务Event Queue里寻找微任务进行执行，这时发现了then，并且进行执行; 第一轮事件循环结束，然后开始第二轮事件循环，当然要去宏任务Event Queue里去寻找，然后发现了setTimeout里的回调函数，然后进行执行; 事件循环，宏任务，微任务的关系如图所示： 下面代码看看执行结果如何? 123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 完整输出为：1，7，6，8，2，4，3，5，9，11，10，12。 第一轮事件循环如下： 整体script代码作为第一个宏任务进入到主线程，遇到console.log(1),输出1； 遇到setTimeout，加入到宏任务 Event Queue，这里记为setTimeout1; 遇到process.nextTick,加入到微任务 Event Queue，我们记为process1； 遇到new Promise,立即执行console.log(7),输出7，然后将then加入到微任务 Event Queue，我们记为then1； 遇到最后一个setTimeout，加入到宏任务 Event Queue，这里记为setTimeout2; 宏任务 微任务 setTimeout1 process1 setTimeout2 then1 上表示第一轮事件循环宏任务结束时，宏任务Event Queue和微任务Event Queue的情况，此时已经输出1,7； 这时有两个微任务process1和then1； 首先执行process1，输出6； 然后执行then1，输出8； 此时，第一轮事件循环已经结束，第一轮事件循环已经输出的值为：1,7,6,8；接下来执行第二轮事件循环，第二轮事件循环从setTimeout1开始。 setTimeout1中首先执行console.log(&#39;2&#39;),输出2； 然后将process.nextTick加入到微任务 Event Queue，这里记为process2； 遇到new Promise,立即执行console.log(4),输出4，然后将then加入到微任务 Event Queue，我们记为then2； 此时宏任务和微任务 Event Queue 的情况如下表： 宏任务 微任务 setTimeout2 process2 then2 第二轮事件循环宏任务执行结束后，已经输出的值为：2,4； 然后执行process2和then2两个微任务； 执行process2输出3； 执行then2输出5； 第二轮事件循环结束后输出2,4,3,5，下面开始第三轮事件循环，第三轮事件循环从setTimeout2开始。 setTimeout2中首先执行console.log(&#39;9&#39;),输出9； 然后将process.nextTick加入到微任务 Event Queue，这里记为process3； 遇到new Promise,立即执行console.log(11),输出11，然后将then加入到微任务 Event Queue，我们记为then3； 此时宏任务和微任务 Event Queue 的情况如下表： 宏任务 微任务 process3 then3 第三轮事件循环宏任务执行结束后，已经输出的值为：9,11； 然后执行process3和then3两个微任务； 执行process3输出10； 执行then3输出12； 最后第三轮事件循环结束后输出值为：9,11,10,12； 终上所述，上面代码的最后输出值为：1,7,6,8,2,4,3,5,9,11,10,12 五、 Js中async/await的执行顺序 async/await是一种异步编程的解决方案，之前的异步解决方案是回调和promise async/await是建立在promise的基础上的 async/await像promise一样，也是非阻塞的 async让异步代码看起来更像同步代码 async有返回值的情况下,async返回的是一个promise对象。 1234567async function f() &#123; console.log('async 执行了'); return 'hello';&#125;let result = f();console.log('result',result); 输出结果为： 从上面的情况可以看出，async有返回值的是一个promise对象，如果在函数中return一个直接量，async会把这个直接量通过Promise.resolve()封装成一个promised对象。 如果async没有返回值，则async返回的也是一个promise，他会通过promise.resolve()封装成一个promise对象，如： 123456async function f() &#123; console.log('async 执行了');&#125;let result = f();console.log('result',result); 输出结果为： await，就是等待，等待的是一个表达式，这个表达式的返回值可以是一个promise对象，也可以是其他值。 很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上，await是让出线程的标志。await后面的函数会先执行一遍，然后就会跳出整个async函数，来执行后面的js栈，等本轮事件循环完成了，再跳回到async函数中等待await。 await后面的返回值，如果是不是一个promise对象，则继续执行async后面的代码，如果是promise对象，则将返回的promise对象放入promise队列。 1234567891011121314151617181920212223242526272829async function async1 () &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;setTimeout(() =&gt; &#123; console.log('setTimeout');&#125;, 0);console.log('start');async1();var promise1 = new Promise((resolve,reject) =&gt; &#123; console.log('promise start'); resolve('promise1');&#125;)promise1.then(resolve =&gt; &#123; console.log(resolve);&#125;)console.log('end'); 输出结果为： 参考资料： Js中async/await的执行顺序详解]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器的协商缓存与强缓存]]></title>
    <url>%2F2019%2F01%2F29%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E4%B8%8E%E5%BC%BA%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[浏览器的协商缓存与强缓存一、什么是浏览器缓存？浏览器缓存是用户在本地磁盘对用户最近请求的文档进行存储，当访问者再次访问同一资源时，浏览器就可以从本地磁盘加载文档。 二、浏览器缓存的优点 减少冗余的数据传输，节省网费； 减少服务器的负担，大大提升网站的性能； 加快客户端加载网页的速度。 三、浏览器缓存的分类浏览器缓存的分类主要为两类，分别是协商缓存和强制缓存。 浏览器在第一次请求获取资源之后，然后根据返回的信息判断来告诉浏览器如何缓存，可能采用的是强制缓存，也可能是告诉浏览器进行协商缓存，这都是需要根据响应的header来决定。 浏览器第一次请求时： 如图: 浏览器再次进行请求时： 如图: 从上图可以看出浏览器缓存包含两种类型，即强缓存和协商缓存,浏览器在第一次请求后，当再次请求时，过程如下： 浏览器在请求某一资源时，会首先获取header 信息，判断是否命中强缓存（cache-control和expires），如果命中则直接从缓存的资源中读取信息，包括缓存的header信息，本次请求就不会与服务器进行通信； 如果本次请求没有命中强缓存，浏览器会发送请求到服务器，请求时会携带一些有关缓存中的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求的header字段信息来比较是否进行协商缓存，如果命中协商缓存，则服务器返回新的响应header信息，但是并不放回资源内容，它会告诉浏览器可以直接从缓存中读取资源，否则返回新的资源内容。 强缓存与协商缓存的比价： 缓存分类 获取资源形式 状态码 是否发送请求到服务器 强缓存 从缓存获取 200（from cache） 否，直接从缓存获取 协商缓存 从缓存获取 304（not modified） 是，请求服务器，通过服务器来告知，缓存是否可用 四、强缓存相关的header字段强缓存直接从缓存中获取资源而不经过服务器；与强缓存相关的header字段有两个： 1.expires，这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 20 Jun 2019 10:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源；（一般指服务器时间） 2.cache-control：max-age=number，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值： no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 注意： Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。 五、协商缓存协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。 1. Last-Modify/If-Modify-Since浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2019 23:59:59 GMT。 当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。 2. ETag/If-None-Match：与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。 与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。 3. 为什么要有Etag？你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间。 注意： Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 六、用户的行为对缓存的影响 用户操作 Expires/Cache-Control Last-Modied/Etag 地址栏回车 有效 有效 页面链接跳转 有效 有效 开窗口 有效 有效 前进回退 有效 有效 F5刷新 无效 有效 Ctrl+F5强制刷新 无效 无效 七、实际问题代码更新到线上后用户浏览器不能自行更新，我们不能要求客户在系统更新后都进行一次缓存清理的操作，我们该如何做？ 在资源请求的URL中增加一个参数，比如：js/index.js?ver=0.0.1。这个参数是一个版本号，每一次部署的时候变更一下，当这个参数变化的时候，强缓存都会失效并重新加载。这样一来，静态资源，部署以后就需要重新加载。这样就比较完美的解决了问题。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面试题总结(一)]]></title>
    <url>%2F2019%2F01%2F22%2FJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[JavaScript面试题总结题目一：12345678910var a = 1;if(!(b in window)) &#123; var b = 2; a += 1;&#125;else &#123; a += 2;&#125;console.log(a) // 3 console.log(b) // undefined 上面的代码可以理解为：在if条件中，变量提升，可以把b提升到作用域顶部，又因为undefined是window的一个全局变量，所以b in window返回true，执行结果为3 undefined 1234567891011var a = 1;var b;if(!(b in window)) &#123; // undefined in window 返回true，因为undefined是window的一个全局变量 b = 2; a += 1;&#125;else &#123; a += 2;&#125;console.log(a)console.log(b) 题目二：1234567891011121314var m = 1;function log() &#123; var m = 2; return function () &#123; // 闭包 m += 1; &#125;&#125;var _log = log(); // function () &#123; m += 1 &#125; 这里的m是log函数里的局部变量m=2_log(); // 把log函数里的m+1，此时局部变量m 为3console.log(m); // 这里的m为全局变量m ,所以为1 题目三：代码一： 123456789var array = [1,2,3];function test (arr) &#123; arr = [];&#125;test(array);console.log(array); // [1,2,3]; 很多人会以为此题的答案是[],而实际上是 [1,2,3],其实我们只需要明白一点，函数传参是按值传递而不是按引用传递的。 js传递参数: js中所有函数参数的传递都是按值传递的，也就是说，函数外部的值复制给函数内部的参数，就和把一个变量的值复制到另外一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同应用类型变量的复制一样。 上面的代码改成如下，代码二： 123456789var array = [1,2,3];function test(arr) &#123; arr.push(4);&#125;test(array);console.log(array); [1, 2, 3, 4] 代码一中的是把外部变量array复制一份传递给参数arr,然后在函数内部，又重新赋值为一个空数组，这里切断了他与外部变量array的联系，也就是改变了指针的执向，而外部array还是执向原来堆内存中的数组对象，这时堆内存里相当于有两个数组对象。代码二中，它们执向的是同一个堆内存中的数组对象，所以在函数内部改变数组，会影响到外部。 题目四：12345678910111213141516171819202122232425262728293031323334353637// 1. 任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。// 2. 私有变量包括函数的参数、局部变量和在函数内部定义的其他函数function Foo () &#123; function getName() &#123; // 在函数内部定义了一个函数（Foo的私有变量） console.log(1); &#125; return this;&#125;// 在函数Foo上定义了一个静态方法Foo.getName = function() &#123; console.log(2);&#125;// 在Foo的原型对象上定义了一个共享方法Foo.prototype.getName = function () &#123; console.log(3);&#125;// 函数表达式var getName = function () &#123; console.log(4);&#125;// 函数声明function getName () &#123; console.log(5);&#125;Foo.getName(); // 2getName(); // 4Foo().getName(); // 4getName(); // 4 上面的代码可以理解为下面这样：12345678910111213141516171819202122232425262728293031323334353637function Foo () &#123; function getName() &#123; // 在函数内部定义了一个函数（Foo的私有变量） console.log(1); &#125; return this;&#125;// 函数声明(函数提升)function getName () &#123; console.log(5);&#125;// 变量提升var getName;// 在函数Foo上定义了一个静态方法,函数的静态静态方法和静态属性只能通过构造函数来访问，实例访问不到Foo.getName = function() &#123; console.log(2);&#125;// 在Foo的原型对象上定义了一个共享方法Foo.prototype.getName = function () &#123; console.log(3);&#125;// 函数表达式getName = function () &#123; console.log(4);&#125;Foo.getName(); // 2getName(); // 4Foo().getName(); // 4getName(); // 4 在上面的题目中，主要考察了js 的function为什么可以添加属性,类的静态方法，变量提升，原型对象，理解这几个知识点就可以了。 js 的function为什么可以添加属性? 12345678910111213141516// 1.构造函数的是公有属性function person()&#123; this.name = 'Tom';&#125;// 构造函数的静态属性function person()&#123;&#125;person.name = 'Tom';// 构造函数的原型共享属性function person()&#123;&#125;person.prototype.name = 'Tom' 解释： ①因为在js里函数也是对象，是Function的实例，function person(){ }; person.name = &#39;Tom&#39;;这是函数对象上直接定义了name属性，只能通过函数名访问，不能通过实例对象访问；②因为Js里面函数也是对象，函数其实也有另外一种写法，var message = new Function(&#39;msg&#39;,&#39;alert(msg)&#39;); // 等价于：function message(msg) { alert(msg); };函数也是new出来的，所以函数其实也是一个对象。所以对象可以添加属性。 类的静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod() // foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 变量提升(参考JavaScript 变量提升):JavaScript 变量提升 原型对象(参考js对象和原型链)js对象和原型链 参考文献： js 的function为什么可以添加属性 阮一峰老师es6教程 《JavaScript高级程序设计》第四章 4.1.3 传递参数]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 变量提升]]></title>
    <url>%2F2019%2F01%2F22%2FJavaScript-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[JavaScript 变量提升一、概念：JavaScript中函数以及变量的声明都会提升到函数的最顶部。变量可以在使用后声明，也就是说变量可以先使用在声明。 变量提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。 二、javaScript中只有声明的变量会提升，初始化的值不会如下代码： 123var a = 10;console.log(a + b); // NaNvar b = 10; 这是因为变量声明 (var b) 提升了，但是初始化(b = 10) 并不会提升，所以 a + b 为NaN; 三、JavaScript简单解析机制浏览器JavaScript引擎遇到script标签就会对js进行预解析，将变量var 和function声明提升，但是不会执行function，然后就进入上下文执行，上下文执行还是执行预解析同样的操作，直到没有var和function，就开始执行上下文。 如： 1234567a = 1;f();var a;function f() &#123; conole.log('0000')&#125;; 预解析：1234567function f() &#123; console.log('0000)&#125;;var a ;a = 1;f(); 上面除了函数声明方式以外还可以用匿名函数的方式。 如： 123var f = function () &#123;&#125;;f(); 注意： 1. 函数声明提升直接把整个函数提升到执行环境的最顶端，所以上面的f()提升后是function f() {}; 2. 函数优先，虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量; 3. 使用匿名函数的方式不存在函数提升，因为函数声明使用的是变量表示的，所以匿名函数不存在函数提升，只存在变量提升。 如： 12345678910var f = function () &#123; console.log(2);&#125;function f() &#123; console.log(1);&#125;f(); // 2 预解析: 1234567891011function f() &#123; console.log(1);&#125;var f;f = function () &#123; console.log(2);&#125;f() 这里的输出结果是2 还有另外一种情况，如： 123456789f(); // 1function f() &#123; console.log(1);&#125;var f = function () &#123; console.log(2);&#125; 所以这里的输出为1，因为这里的函数表达式（匿名函数）不会被函数提升，就像上面的预解析一样，f虽然也被提升了，但是他是当做了一个变量，因为这个时候f是通过var f声明的变量，只不过他指向了一个函数，所以他提升后的代码等价于下面的预解析代码： 预解析： 1234567891011function f() &#123; console.log(1);&#125;var f;f();f = function () &#123; console.log(2);&#125; 四、let和constvar命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let、const命令改变了语法行为，let、const声明的变量只在它所在的代码块有效，它所声明的变量一定要在声明后使用，否则报错。 1234567// ar 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[同源策略以及跨域]]></title>
    <url>%2F2019%2F01%2F15%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[同源策略以及跨域一、同源策略同源策略(Same-Origin Policy)。所谓的 同源 是域名、协议、端口号相同。不同的客户端脚本（javascript，ActionScript）在没有授权的情况下，不能读取对方资源。简单来说，浏览器允许包含在页面A的脚本访问第二个页面B的数据资源，这一切是建立在A和B页面是同源的基础上。 二、跨域与跨域请求跨域 简单的来说，指的是两个资源非同源。出于安全方面的考虑，页面中的JavaScript在请求非同源的资源时就会出 跨域问题 ——即跨域请求，这时，由于同源策略，我们的请求会被浏览器禁止。也就出现了 我们常说的 跨域 问题。 下面，我们看一下，具体哪些情况会出现跨域问题(具体策略限制)： 三、跨域解决方案1. JSONP跨域为了便于客户端使用数据，逐渐形成了一种非正式传输协议。人们把它称作JSONP。该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 JSONP实现原理: js 请求资源会被限制，但是在页面中，script标签是没有限制的，img，iframe标签也是一样的； 通过sctipt标签的src属性，请求服务器，并且通过参数（如：?callback=func,func为本地的一个方法）,告诉服务器返回指定格式的js脚本，并将数据封装在此脚本中； 服务器在配合客户端返回一段脚本(如：{count: 1, start: 0, total: 1572}),其实返回的就是客户端一个本地的可执行方法，并且将要返回的数据封装在了参数里; 请求到资源后，本地就会执行此方法，通过对参数的处理，也就获取到了我们所要的数据。 假如我们想要请求豆瓣API的接口去获取数据https://api.douban.com/v2/book/search?q=javascript&amp;count=1，直接在浏览器里输入地址请求可以返回数据，是没有问题的。如图： 但是如果我们执行下下面一段代码的时候可能会出现跨域问题而报错。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JSONP跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;script&gt; window.onload = function()&#123; let btn = document.getElementById('btn'); btn.onclick = function () &#123; let xhr = new XMLHttpRequest(); //豆瓣图书API地址 let url = 'https://api.douban.com/v2/book/search?q=javascript&amp;count=1' xhr.open('get',url); xhr.send(); if(xhr.readystateonchange == 4 &amp;&amp; xhr.status == 200) &#123; console.log('success',xhr.response); &#125;else&#123; console.log('err',xhr); &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器截图为： 当出现上述情况时，客户端请求页面和服务端不属于同源，已经出现了跨域，这时我们可以使用JSONP来解决上述问题。 JSONP跨域客户端的具体实现： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JSONP跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //回调函数 function handleResponse(response) &#123; console.log('success...',response); &#125; window.onload = function ()&#123; let btn = document.getElementById('btn'); btn.onclick = function() &#123; //创建一个script标签 let script = document.createElement('script'); //设置srript的src script.src = "https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse"; //插入到文档中 document.body.insertBefore(script,document.body.firstChild) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器截图为： 2. postMessage跨域window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后（e.g., 在该方法之后设置的事件、之前设置的timeout 事件,etc.）向目标窗口派发一个 MessageEvent 消息。 该MessageEvent消息有四个属性需要注意： message 属性表示该message 的类型； data 属性为 window.postMessage 的第一个参数；origin 属性表示调用window.postMessage() 方法时调用页面的当前状态； source 属性记录调用 window.postMessage() 方法的窗口信息。 语法： 1otherWindow.postMessage(message, targetOrigin, [transfer]); 参数： otherWindow ： 其他窗口的一个引用，比如在A页面中使用的window； message ： 将要发送到其他 window的数据； targetOrigin ：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI； transfer(可选) ： 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 示例代码如下： 123456789// postMessage// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息window.postMessage('data', 'http://B.com');// 在窗口B中监听window.addEventListener('message', function (event) &#123; console.log(event.origin); console.log(event.source); console.log(event.data);&#125;, false); 3. WebSocketWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 特点： 没有同源限制，客户端可以与任意服务器通信。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 12345678910111213141516var ws = new WebSocket("wss://echo.websocket.org");ws.onopen = function(evt) &#123; console.log("Connection open ..."); ws.send("Hello WebSockets!");&#125;;ws.onmessage = function(evt) &#123; console.log( "Received Message: " + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log("Connection closed.");&#125;; 浏览器截图如下： 详情参考阮一峰老师的WebSocket 教程 4. CORSCORS需要浏览器和服务器的同时支持。目前所有的浏览器都支持，IE浏览器不能低于IE10。 整个CORS通信的过程都是浏览器自动完成的，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样，浏览器一旦发现AJAX请求，就会添加一些附加头信息，有时还会多出一次附加请求，但是用户不会有感觉。因此实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以实现跨源通信了。 详情参考阮一峰老师的跨域资源共享 CORS 详解]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js对象和instanceof底层原理以及typeof的使用]]></title>
    <url>%2F2019%2F01%2F15%2Fjs%E5%AF%B9%E8%B1%A1%E5%92%8Cinstanceof%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Atypeof%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[js原型链和instanceof底层原理以及typeof的使用一、typeof操作符鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型—— typeof 就是负责提供这方面信息的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串。 变量值类型 typof返回值 值未定义 undefined 布尔值 boolean 字符串 string 数值 number 对象或null object 函数 function 123456789101112131415var a;var b = null;var s = '123';var d = true;var o = &#123;&#125;;var f = function () &#123;&#125;;var num = 123;console.log(typeof a); // undefinedconsole.log(typeof b); // objectconsole.log(typeof s); // stringconsole.log(typeof d); // booleanconsole.log(typeof o); // objectconsole.log(typeof f); // functionconsole.log(typeof num); // number 二、instanceofinstanceof 可以判断一个引用对象是否属于某构造函数，instanceof的判断逻辑是从当前对象引用的__proto__顺着原型链一层一层网上找，是否能够找到对应的prototype，如果找到了就返回true，否则返回false。 模拟instanceof的实现 123456789101112131415161718192021/** * * @param &#123;Object&#125; L instanceof左侧的参数 * @param &#123;Function&#125; R instanceof右侧的参数*/function instance_of (L,R) &#123; let r = R.prototype; // 取R的显示原型 let l = L.__proto__; // 取L的隐式原型 while (true) &#123; // null 不是任何对象的实例，如果左侧为null的话，直接返回false if(L === null) &#123; return false; &#125; if(l === r) &#123; // 当R的显示原型和L的隐式原型相等时返回true return true; &#125; l = l.__proto__; &#125;&#125; 使用instanceof时有两种情况需要考虑： 第一种情况：没有发生继承时； 第二种情况：发生继承时； 第一种情况：没有发生继承时123456789101112131415161718function Parent (gender) &#123; this.gender = gender;&#125;function Child (name,age) &#123; this.name = name; this.age = age;&#125;let c = new Child('tom',20);let p = new Parent('男');console.log(c instanceof Child); // trueconsole.log(p instanceof Parent); // trueconsole.log( c instanceof Object); // trueconsole.log( p instanceof Object); // true 没有发生继承时，instanceof的工作流程分析： 123456789101112131415function instance_of (L,R) &#123; let r = R.prototype; // r为Child.prototype let l = L.__proto__; // l为c.__proto__ while (true) &#123; if(L === null) &#123; // 不通过 return false; &#125; if(l === r) &#123; // 判断 此时l为c.__proto__ 和r为Child.prototype是否相等 return true; &#125; l = l.__proto__; &#125;&#125; 上面的代码中执行c instanceof Parent的时候，l和r执向的是同一个原型对象，所以返回true 第二种情况：发生继承时123456789101112131415161718function Parent (gender) &#123; this.gender = gender;&#125;function Child (name,age,gender) &#123; Parent.call(this,gender); this.name = name; this.age = age;&#125;Child.prototype = new Parent(); // 改变了原型指向，实现继承var c = new Child('tom',20,'男');console.log( c instanceof Child); // trueconsole.log( c instanceof Parent); // trueconsole.log( c instanceof Object); // true 发生继承时，instanceof的工作流程分析： ① 首先看一下c instanceof Child 123456789101112131415function instance_of (L,R) &#123; let r = R.prototype; // r为Parent的实例p let l = L.__proto__; // l也为Parent的实例p while (true) &#123; if(L === null) &#123; // 不通过 return false; &#125; if(l === r) &#123; // 判断 此时l为Parent的实例p 和r为Parent的实例p相等 return true; &#125; l = l.__proto__; &#125;&#125; 即使发生了原型继承，c instanceof Child 依然是成立的 ② 再看一下c instanceof Parent 123456789101112131415function instance_of (L,R) &#123; let r = R.prototype; // r为Parent.prototype let l = L.__proto__; // l也为Parent的实例p while (true) &#123; if(L === null) &#123; // 不通过 return false; &#125; if(l === r) &#123; // 判断 此时l为Parent的实例p 和r为Parent.prototypepb不相等 return true; &#125; l = l.__proto__; // 此时l为Parent.prototype &#125;&#125; c instanceof Parent返回值为true，这就证明了c继承了Parent。 结论： 用于判断一个引用类型是否属于某构造函数； 还可以在继承关系中用来判断一个实例是否属于它的父类型。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6中promise的用法]]></title>
    <url>%2F2019%2F01%2F14%2FES6%E4%B8%ADpromise%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[promise的基本使用一、promise的含义： promise是异步编程的一种解决方案，比传统的回调函数和事件更加强大、合理。 promise就是一个容器，里面保存着某个未来才会结束的事件的结果。 二、promise对象的特点： 对象的状态不受外界的影响。promise对象代表一个异步操作，有三种状态:pending(进行中),fulfilled(已成功),reject(已失败)。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 状态一旦改变，就不会再变回来。promise对象状态的改变只能有两种情况：从pending到reject和从pending到fulfilled。 三、promise的用法： promise对象是一个构造函数，用来生成promise实例。 12345678910111213const promise = new Promise(function (resolve,reject) &#123; if(/*success*/) &#123; // 当promise对象从pending到resolved后执行 resolve(data); &#125;else &#123; // 当promise对象从pending到rejected后执行 reject(data); &#125;&#125;)promise.then(data =&gt; &#123; console.log('data',data);&#125;，err =&gt; &#123; throw new Error(err);&#125;) 模拟promise异步过程：得到一个随机数，如果这个随机数大于0.8则执行resolved，否则执行rejected。 12345678910111213141516function getRandom() &#123; let random = Math.random(); return new Promise((resolve,reject) =&gt; &#123; if(random &lt;= 0.8) &#123; setTimeout(resolve,500,random) &#125;else &#123; setTimeout(reject,500,random); &#125; &#125;)&#125;getRandom().then(res =&gt; &#123; console.log(`成功了,$&#123;res&#125;`);&#125;,err =&gt; &#123; console.log(`失败了,$&#123;err&#125;`);&#125;) promise新建后就会执行 1234567891011121314let promise = new Promise((resolve,rejcet) =&gt; &#123; console.log('promise'); resolve();&#125;)promise.then(res =&gt; &#123; console.log('resolved');&#125;)console.log('hello');// promise// hello// resolved promise在新建后会立即执行，所以首先输出的是promise,然后输出hello,最后在本脚本所有的同步任务执行完成后，才会执行then方法指定的回调函数，所以resolved最后输出。 promise对象中，如果调用resolve和reject函数时带有参数，那么他们的参数可以传递给then的回调函数，resolve和reject函数的参数除了可以正常值以外，还可以是另外一个promise实例。 1234567891011121314let promise_1 = new Promise((resolve,reject) =&gt; &#123; // 模拟1s后从pending到resolved setTimeout(resolve,1000,'success');&#125;);// 模拟一个promise对象接受另外一个promise成功的状态let promise_2 = new Promise((resolve,reject) =&gt; &#123; resolve(promise_1);&#125;)promise_2.then(res =&gt; &#123; console.log(res);&#125;) 123456789101112131415let promise_3 = new Promise((resolve, reject) =&gt; &#123; // 模拟1s后从 pending到rejected setTimeout(reject,1000,'failed');&#125;);// 模拟一个promise对象接受另外一个promise失败的状态let promise_4 = new Promise((resolve,reject) =&gt; &#123; resolve(promise_3);&#125;)promise_4.then(res =&gt; &#123; console.log(res);&#125;,err =&gt; &#123; console.log(err);&#125;) 上面代码promise_2中的resolve接收promise_1对象作为参数，此时，1s后promise_1执行成功，并且把promise_1的执行结果传递给Promise_2;promise_4中的resolve接收promise_3对象作为参数，此时，1s后promise_1执行失败，并且把promise_1的执行结果传递给Promise_4; 四、promise.prototype.then() promise实例具有then方法，也就是说，then方法是定义在原型对象上Promise.prototype上的，它的作用就是为promise实例状态改变时添加回调函数； then方法返回的是一个心得promise实例，因此可以采用链式写法，即then方法后面可以在调用另外一个then方法。 123456789let promise_1 = new Promise((resolve,reject) =&gt; &#123; resolve('success');&#125;)promise_1.then(res =&gt; &#123; return res;&#125;).then(res =&gt; &#123; console.log(res); // success&#125;) 上面的代码，使用then方法，依次指定了两个回调函数。第一个then中的回调函数完成后，会将返回的结果作为参数，传入第二个then中的回调函数。第二个回调函数会等待第一个回调函数完成后才会执行。 五、promise.prototype.catch()promise.prototype.catch()方法是.then(null,err=&gt; {})或者.then(undefined,err=&gt;{})的别名，用于指定错误发生时的回调函数。 123456789101112131415161718192021222324252627282930313233// 推荐写法let promise_1 = new Promise((resolve,reject) =&gt; &#123; reject('error');&#125;)promise_1.then(res =&gt; &#123; return res;&#125;).catch(err =&gt; &#123; console.log(err);&#125;)// 等同于let promise_1 = new Promise((resolve, reject) =&gt; &#123; reject('error');&#125;)promise_1.then(res =&gt; &#123; return res;&#125;,err =&gt; &#123; console.log(err);&#125;)// 等同于let promise_1 = new Promise((resolve, reject) =&gt; &#123; reject('error');&#125;)promise_1.then(res =&gt; &#123; return res;&#125;).then(null,err =&gt; &#123; console.log(err);&#125;) 六、promise.prototype.finally()finally方法用于指定不管promise最后的状态是成功还是失败都会执行的操作。finally方法不接收任何参数，finally里面的操作应该是与状态无关的。 123456789let promise = new Promise((resolve,reject) =&gt; &#123; resolve('success');&#125;)promise.then(res =&gt; &#123; return res;&#125;).finally(() =&gt; &#123; console.log('finally');&#125;) 七、promise.all()promise.all()方法用于将多个promise实例，包装成一个新的promise实例。 1let p = Promise.all([p1,p2,p3]); 新的p实例的状态由p1,p2,p3的状态决定： 只有p1,p2,p3的状态都为fulfilled，p的状态才会变为fulfilled，此时p1,p2,p3的返回值组成一个数组，传递给p的回调函数； 只要p1,p2,p3的状态有一个为rejected，p的状态才会变为rejected，此时第一个被rejected的实例的返回值，会传递给p的回调函数； 12345678910111213141516171819202122232425262728293031// 三个都为fulfilled的情况 let promise = [1,2,3].map(item =&gt; &#123; return new Promise((resolve,reject) =&gt; &#123; resolve(item); &#125;)&#125;)Promise.all(promise).then(res =&gt; &#123; console.log('success',res); // success [ 1, 2, 3 ]&#125;).catch(err =&gt; &#123; console.log('err',err);&#125;) // 有一个为rejected的情况let promise = [1, 2, 3].map(item =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if(item == 2) &#123; reject(item); &#125;else &#123; resolve(item); &#125; &#125;)&#125;)Promise.all(promise).then(res =&gt; &#123; console.log('success',res);&#125;).catch(err =&gt; &#123; console.log('err',err); // err 2&#125;) 八、promise.race()promise.race()方法同样将多个promise实例，包装成一个新的promise实例。 1let p = Promise.race([p1,p2,p3]); 新的p实例的状态由p1,p2,p3的状态决定： 只要p1,p2,p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的promise的实例返回的值，就传递给p的回调函数。 12345678910111213141516let promise = [1, 2, 3].map(item =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if(item == 2) &#123; reject(item); &#125;else &#123; resolve(item); &#125; &#125;)&#125;)Promise.race(promise).then(res =&gt; &#123; console.log('success', res); // success 1&#125;).catch(err =&gt; &#123; console.log('err',err);&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6中class的用法]]></title>
    <url>%2F2019%2F01%2F14%2FES6%E4%B8%ADclass%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[class的基本使用一、es6的 class 与es5 的构造函数123456789101112131415161718192021// es6 classclass Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; getName () &#123; console.log('get name',this.name); &#125;&#125;// es5 构造函数function Person (name,age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function () &#123; console.log('get name',this.name);&#125; class 里面的constructor方法就是构造方法，而this关键字则代表实例对象; 也就是说es5的构造函数Person，对应的就是es6的Person类的constructor方法。 二、class的数据类型与constructor的指向123456789101112class Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; getName () &#123; console.log('get name',this.name); &#125;&#125;typeof Person // "function"Person.prototype.constructor === Person // true typeof Person 打印结果是”function”,表名类的数据类型就是函数; Person.prototype.constructor === Person打印结构是true,表名类本身就指向构造函数。 三、构造函数的prototype属性，在es6中继续存在，实际上es6中class的所有方法都是定义在类的prototype属性上的12345678910111213141516class Person &#123; constructor (name,age) &#123; this.name = name; this.age = age; &#125; getName () &#123; console.log('get name',this.name); &#125;&#125;// 等同于Person.prototype = &#123; constructor() &#123;&#125;, getName() &#123;&#125;,&#125; 四、constructor方法constructor方法是类默认的构造方法，通过new命令生成实例对象，自动调用该方法，一个类必须有一个constructor方法，如果没有显示定义，则会默认添加。 12345678class Person &#123;&#125;// 等同于class Person &#123; constructor()&#123;&#125;&#125; constructor方法默认返回实例对象(即this)，完全可以指定返回另外一个对象。 12345class Person &#123; constructor() &#123; return Object.create(null); &#125;&#125; 五、this指向 类的方法内部如果含有this，则默认指向类的实例; 如果单独使用，很可能报错; 12345678910111213141516171819202122class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; getName() &#123; console.log('get name'); this.getAge(); &#125; getAge() &#123; console.log('get age',this.age); &#125;&#125;let p = new Person('jack',20);p.getName(); const &#123; getName &#125; = p;getName(); // TypeError: Cannot read property 'getAge' of undefined getName 方法中的this默认指向类的实例p; 如果const { getName } = p,将这个方法单独提取出来，this会指向当前指向环境，而不是当前实例对象,会因为找不到getAge()方法而报错; 解决方案一：在构造方法中绑定this123456789101112131415161718192021222324class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; // 在constructor方法中绑定this this.getName = this.getName.bind(this); &#125; getName() &#123; console.log('get name'); this.getAge(); &#125; getAge() &#123; console.log('get age', this.age); &#125;&#125;let p = new Person('jack', 20);p.getName();const &#123; getName &#125; = p;getName(); 解决方案二：箭头函数12345678910111213141516171819202122class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; getName = () =&gt; &#123; console.log('get name'); this.getAge(); &#125; getAge() &#123; console.log('get age', this.age); &#125;&#125;let p = new Person('jack', 20);p.getName();const &#123; getName &#125; = p;getName(); 六、类的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前面加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为静态方法。 12345678910class Person &#123; static getName() &#123; console.log('hello'); &#125;&#125;Person.getName(); // hellolet p = new Person();p.getName(); // p.getName is not a function Person类的getName方法前面有一个static关键字，表明该方法是一个静态方法; 该方法只能在Person类来调用，不能在实例上调用; 123456789101112class Person &#123; static getName() &#123; console.log('hello'); // 静态方法里的this代表当前类，可以调用其他静态方法 this.getAge(); &#125; static getAge() &#123; console.log('age'); &#125;&#125;Person.getName(); // hello age 如果静态方法里面包含this关键字，则this指向的是类，而不是实例。 父类的静态方法可以被继承： 1234567891011class Person &#123; static getName() &#123; console.log('parent hello'); &#125;&#125;class Child extends Person &#123;&#125;Child.getName(); // parent hello 子类可以继承父类的静态方法，如上面代码，子类Child继承父类Person的getName静态方法，并且调用; 1234567891011121314class Person &#123; static getName() &#123; console.log('parent hello'); &#125;&#125;class Child extends Person &#123; static getChildName() &#123; // 通过super对象调用父类的静态方法 super.getName(); &#125;&#125;Child.getChildName(); // parent hello 静态方法也可以通过super对象来调用; 七、类的静态属性静态属性指的是class本身的属性，即class.PropName,而不是定义在实例对象上的属性。 方式一：老写法 12345class Person &#123;&#125;Person.prop = 'tom';Person.prop; // tom 方式二：新写法 1234class Person &#123; static prop = 'tom';&#125;Person.prop; 八、实例属性新写法：实例属性除了可以写在constructor方法里面，还可以写在类的最顶层。 1234567891011// 老写法class Person &#123; constructor (age) &#123; this.age = 20 &#125;&#125;// 新写法class Person &#123; age = 20;&#125; 九、extends继承的基本用法123456class Person &#123; &#125;class Child extends Person &#123;&#125; Child 通过extends继承了父类Person的所有属性和方法; 12345678910class Person &#123;&#125;class Child extends Person &#123; constructor() &#123; &#125;&#125;let c = new Child(); // Must call super constructor in derived class before accessing 'this' or returning from derived constructor 子类必须在constructor方法中调用super方法，否则会报错； es6的继承机制是先将父类的实例对象的属性和方法，加到this上(所以必须先调用super方法)；然后在再子类的构造函数修改this； 12345678910111213141516class Person &#123;&#125;class Child extends Person &#123; &#125;// 等同于class Person &#123;&#125;class Child extends Person &#123; constructor(...args) &#123; super(...args) &#125;&#125; 如果子类没有constructor方法，这个方法会被默认添加，并且同时会在构造函数中调用super方法，也就是说，不管有没有显示定义，任何一个子类都有constructor方法。 12345678910111213141516class Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125;&#125;class Child extends Person &#123; constructor(name,age,gender) &#123; // this.gender = gender; // Must call super constructor in derived class before accessing 'this' or returning from derived constructor super(name,age); this.gender = gender; // 正确 &#125;&#125;let c = new Child('tom',20,'男'); 注意：只有在子类的构造函数中，只有调用super之后，才可以使用this关键字； 上面的代码中，由于在子类的constructor方法中没有调用super关键字，就使用this关键字会报错，而放在super之后就是正确的。 十、super关键字super关键字既可以当作函数使用，也可以当作对象使用。 super作为函数调用，代表父类的构造函数，es6要求，子类的构造函数必须执行一次super函数。super虽然代表父类的构造函数，但是返回的却是子类的实例，即super内部的this执向的是子类的实例。作为函数时，super()只能用在子类的构造函数中，用在其他地方会报错。 super作为对象是，在普通方法中，代表父类的原型对象，在静态方法中，执向父类。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js对象和原型链]]></title>
    <url>%2F2019%2F01%2F06%2Fjs%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[js对象和原型链一、创建对象的几种方式 对象直接量： 12var o1 = &#123; name : 'tom'&#125;;var o2 = new Object(&#123; name : 'jack' &#125;); 构造函数： 12345function Person (name,age) &#123; this.name = name; this.age = age;&#125;var p = new Person('rose',28); Object.create()方式： 12var p = &#123; name : 'john'&#125;;var p1 = Object.create(p); 二、new做了哪些事?1. 新建一个对象； 2. 修改新建对象的原型对象为构造函数的原型对象； 3. 修改this的指向； 4. 返回新建对象。 123456789101112131415161718192021222324252627282930313233343536/* * 1. 新建一个对象 * 2. 修改新建对象的prototype指向构造函数的prototype * 3. 修改this的指向 * 4. 返回新建对象（如果构造函数没有返回值）*/function new2 (callback) &#123; // 1.新建一个对象 // 2. 修改新建对象的prototype指向构造函数的prototype let obj = Object.create(callback.prototype); /* * 或者 var obj=&#123;&#125;; obj.__proto__= callback.prototype; */ // 修改this的指向为新建对象obj let result = callback.call(obj); // 返回新建对象 if(typeof result === 'object') &#123; // 如果构造函数有返回值，并且是对象，则返回这个对象 return result; &#125;else &#123; // 否则返回新建的对象 return obj; &#125;&#125;function P () &#123; this.name = "name";&#125;var p1 = new2(P) 注意：call、apply、bind的简单区别： 1. call、apply都是立即执行函数，bind是返回一个新的函数，他们三个的作用都是为了改变this的指向,第一个参数都是this要指向的对象； 2. call和bind的第一个参数可以跟很多个参数，而apply的第二个参数是一个数组。 三、构造函数、原型、实例之间的关系：每个构造函数都有一个原型对象，原型对象都有一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。------《JavaScript高级程序设计》 123456789function Person (name,age) &#123; this.name = name; this.age = age;&#125;var p = new Person('tom',22);console.log(p);console.log(p.__proto__ === Person.prototype);console.log(p.constructor);console.log(p.__proto__.constructor === Person.prototype.constructor); 他们之间的关系如下图： 四、对象的继承： 对象的继承一：借助构造函数实现继承 12345678910111213141516171819202122function Parent_1 (name,age) &#123; this.name = name; this.age = age;&#125;Parent_1.prototype.say = function () &#123; console.log('parent say hello');&#125;function Child_1 (naem,age,gender) &#123; // 借助构造函数实现继承的关键代码 // 通过在子类里调用父类构造函数，并且改变this的指向实现继承 Parent_1.call(this,name,age); this.gender = gender;&#125;var c1 = new Child_1('jack',20,'男');c1.say() // Uncaught TypeError: c1.say is not a function 借助构造函数实现继承的关键代码的就是Parent_1.call(this,name,age),通过在子类构造函数中调用父类的构造函数并且修改this的执行来实现继承。 缺点：可以实现继承，但是只能继承父类构造函数的属性和方法，不能继承父类原型链上的方法和属性. 对象的继承二：原型链继承 123456789101112131415161718192021function Parent_2 (name,age) &#123; this.name = 'parent name'; this.age = 20;&#125;Parent_2.prototype.say = function () &#123; console.log('parent say hello');&#125;function Child_2 (gender) &#123; this.gender = gender;&#125;// 借助原型链继承的关键代码// 修改子类构造函数的原型修改为父类父类的实例，这样子类实例就可以通过原型链，继承父类构造函数中的属性和方法，而且也可以继承父类构造函数原型中的属性和方法Child_2.prototype = new Parent_2();var c2 = new Child_2('男')c2.say() // parent say hello 123456789101112131415161718192021222324function Parent_2 (name,age) &#123; this.name = 'parent name'; this.age = 20; this.data = [1,2,3];&#125;Parent_2.prototype.say = function () &#123; console.log('parent say hello');&#125;function Child_2 (gender) &#123; this.gender = gender;&#125;// 修改子类构造函数的原型修改为父类构造函数的实例Child_2.prototype = new Parent_2();var c2 = new Child_2('男')var c3 = new Child_2('男')c2.say() // parent say helloc2.data.push(4);console.log(c2.data); // [1, 2, 3, 4]console.log(c3.data); // [1, 2, 3, 4] 原型链继承的关键代码就是Child_2.prototype = new Parent_2(),通过修改子类构造函数的原型链为父类实例，这样在访问子类实例的时候，子类实例会通过原型链访问到父类实例中的属性和方法，而且还会通过原型链来继承父类构造函数原型对象中的属性和方法。 缺点：通过原型链可以解决通过构造函数实现继承中的缺点，不仅可以继承父类构造函数中的属性和方法，而且还可以继承父类原型对象中的属性和方法，但是如过父类构造函数中的属性为引用类型的时候，通过修改一个实例属性的时候，会影响到其他实例。 对象的继承三：组合继承 123456789101112131415161718192021222324252627282930function Parent_3 () &#123; this.name = 'parent'; this.data = [1,2,3];&#125;Parent_3.prototype.say = function () &#123; console.log('hello word');&#125;function Child_3 (gender) &#123; // 通过构造函数来继承父类构造函数中的属性和方法 Parent_3.call(this); this.gender = '男';&#125;// 通过修改子类构造函数的原型为父类构造函数实例来继承父类构造函数的属性和方法，以及继承父类构造函数原型对象上的属性和方法Child_3.prototype = new Parent_3();var c4 = new Child_3();var c5 = new Child_3();console.log(c4.constructor === Child_3 ) // falsec4.data.push(4);console.log(c4.data); // [1, 2, 3, 4]console.log(c5.data); // [1, 2, 3]console.log(c4.say()); // hello wordconsole.log(c5.say()); // hello word 缺点：在上面的组合继承中，在代码`Child_3.prototype = new Parent_3()`和`Child_3.prototype = new Parent_3()`中Parent_3()执行了两次，还可以对其进行优化。`console.log(c4.constructor === Child_3 )`的执行结果为`false`，说明我们修改了`Child_3.prototype`中constructor的指向，这不是我们所希望看到的。 组合继承的优化一: 123456789101112131415161718192021222324252627282930function Parent_3 () &#123; this.name = 'parent'; this.data = [1,2,3];&#125;Parent_3.prototype.say = function () &#123; console.log('hello word');&#125;function Child_3 (gender) &#123; // 通过构造函数来继承父类构造函数中的属性和方法 Parent_3.call(this); this.gender = '男';&#125;// 通过修改子类构造函数的原型为父类构造函数的原型Child_3.prototype = Parent_3.prototype;var c4 = new Child_3();var c5 = new Child_3();console.log(c4.constructor === Child_3 ) // falsec4.data.push(4);console.log(c4.data); // [1, 2, 3, 4]console.log(c5.data); // [1, 2, 3]console.log(c4.say()); // hello wordconsole.log(c5.say()); // hello word 在上面的代码中通过Child_3.prototype = Parent_3.prototype来解决Parent_3执行两次的问题。 组合继承的优化二: 12345678910111213141516171819202122232425262728293031function Parent_3 () &#123; this.name = 'parent'; this.data = [1,2,3];&#125;Parent_3.prototype.say = function () &#123; console.log('hello word');&#125;function Child_3 (gender) &#123; // 通过构造函数来继承父类构造函数中的属性和方法 Parent_3.call(this); this.gender = '男';&#125;// 通过修改子类构造函数的原型为父类构造函数的原型Child_3.prototype = Parent_3.prototype;Child_3.prototype.constructor = Child_3var c4 = new Child_3();var c5 = new Child_3();console.log(c4.constructor === Child_3 ) // truec4.data.push(4);console.log(c4.data); // [1, 2, 3, 4]console.log(c5.data); // [1, 2, 3]console.log(c4.say()); // hello wordconsole.log(c5.say()); // hello word 在上面代码中通过Child_3.prototype.constructor = Child_3来解决Child_3.prototype`中constructor的指向问题。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css盒模型]]></title>
    <url>%2F2019%2F01%2F05%2Fcss%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[css盒模型一、css盒模型分类：css盒模型分为IE盒模型和标准盒模型，以下是IE盒模型和标准盒模型的对比 分类 区别 box-sizing IE盒模型 content包含padding和border border-box 标准盒模型 content不包含padding和border content-box 二、js如何获取到盒模型的宽度和高度？以下是三种获取dom节点盒模型宽度和高度的方法以及他们的优缺点 方式 优点 缺点 dom.style.width/height 略 只能获取到内联样式的宽度和高度 dom.current.style.width/height 可以获取到当前dom节点的宽度和高度、无论是内联还是外部链接样式 只有IE浏览器支持 window.getComputedStyle(dom).width/height 兼容性比较好，可以获取到当前dom节点的宽度和高度，无论是内联还是外部链接样式 略 三、BFC BFC定义 BFC(Block formatting context)块级格式化上下文。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC的布局规则 内部的box会在垂直方向上一个接一个的放置； BFC在页面上是一个独立的容器，不会影响到外部元素也不会被外部元素影响到； BFC计算高度时，浮动元素也参与在内； BFC区域不会与浮动元素发生重叠(通常可以用来清除浮动)； 属于同一个BFC的两个相邻box的margin会发生重叠； 如何生成BFC？ overflow不为visible； float为left、right； position为absolute、fixed； display为inline-block、table、table-cell、flex等； BFC的应用 应用一：解决属于同一个BFC内相邻的box发生margin重叠问题 1.外边距重叠情况 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .container &#123; border: 1px solid #fff; width: 200px; height: 200px; background: pink; &#125; .children_1,.children_2 &#123; height: 50px; line-height: 50px; width: 50px; text-align: center; margin: 20px; &#125; .children_1 &#123; border: 1px solid red; &#125; .children_2 &#123; border: 1px solid blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="children_1"&gt;box1&lt;/div&gt; &lt;div class="children_2"&gt;box2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如图: 2.解决方案: 在每一个子元素的外层添加一个父元素，并且让父元素生成一个BFC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .container &#123; border: 1px solid #fff; width: 200px; height: 200px; background: pink; &#125; .children_1,.children_2 &#123; height: 50px; line-height: 50px; width: 50px; text-align: center; margin: 20px; &#125; .children_1 &#123; border: 1px solid red; &#125; .children_2 &#123; border: 1px solid blue; &#125; .bfc_container &#123; display: table; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="bfc_container"&gt; &lt;div class="children_1"&gt;box1&lt;/div&gt; &lt;/div&gt; &lt;div class="bfc_container"&gt; &lt;div class="children_2"&gt;box2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如图： 应用二：页面两栏布局，左侧浮动且宽度固定，右侧生成BFC，宽度自适应 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .left &#123; float: left; width: 200px; height: 100px; background-color: red; &#125; .right &#123; height: 100px; overflow: hidden; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;左侧浮动、固定宽度&lt;/div&gt; &lt;div class="right"&gt;右侧生成BFC自适应&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如图： 3.清除浮动: 子元素浮动后，父元素高度为0，可以通过把父元素生成一个BF来解决(BFC计算高度时，浮动元素也参与在内) 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .container &#123; overflow: hidden; &#125; .left &#123; float: left; width: 200px; height: 100px; line-height: 100px; text-align: center; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;子元素浮动&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如图：]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM事件]]></title>
    <url>%2F2019%2F01%2F04%2FDOM%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[DOM事件类一、基本概念：DOM事件级别 DOM事件级别 DOM事件 描述 DOM0 element.onclick=function(){} DOM0时代制定的DOM事件标准 DOM2 element.addEventListener(‘click’,function(){ },false) ①DOM2时代制定的事件监听；②DOM1没有制定与事件相关的；③false,默认表示冒泡阶段触发，true表示捕获阶段 DOM3 element.addEventListener(‘keyup’,function(){ },false) DOM3在DOM2的基础上增加了一些鼠标键盘事件 二、DOM事件模型（冒泡、捕获） 事件冒泡：是由IE团队提出来的，即事件是由最具体的那个元素j接收，然后逐级向上传播 事件捕获： 事件捕获是由NetSpace团队提出来的，是由最上一级节点先接收事件，然后向下传播到具体的节点 三、DOM事件流“DOM2级事件”规定了事件l流包含3个阶段，事件捕获阶段，目标阶段和事件冒泡阶段。首先发生的事件捕获阶段，然后实际的目标接收到事件，最后阶段是冒泡阶段。 四、DOM事件捕获的具体流程window -&gt; document(文档对象) -&gt; html -&gt; body -&gt; div(具体目标元素) 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;DOM事件捕获流程&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 所有的addEventListener最后一个参数是true，表示在捕获阶段，不加默认为false，在冒泡阶段触发 // window window.addEventListener('click',function() &#123; console.log('window') &#125;,true) // document document.addEventListener('click',function () &#123; console.log('document') &#125;,true) // html document.documentElement.addEventListener('click',function()&#123; console.log('html') &#125;,true) // body document.body.addEventListener('click',function()&#123; console.log('body') &#125;,true) // div let btn = document.getElementById("btn"); btn.addEventListener('click',function () &#123; console.log('div') &#125;,true) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 五、DOM事件冒泡的具体流程div(具体目标元素) -&gt; body -&gt; html -&gt; document(文档对象) -&gt; window 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;DOM事件冒泡流程&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // window window.addEventListener('click', function () &#123; console.log('window') &#125;, false) // document document.addEventListener('click', function () &#123; console.log('document') &#125;, false) // html document.documentElement.addEventListener('click', function () &#123; console.log('html') &#125;, false) // body document.body.addEventListener('click', function () &#123; console.log('body') &#125;, false) // div let btn = document.getElementById("btn"); btn.addEventListener('click', function () &#123; console.log('div') &#125;, false) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、Event对象的具体应用 事件对象 描述 event.preventDefault() 阻止默认事件 event.stopPropagation() 阻止冒泡 event.currentTarget() 当前绑定事件对象的元素 event.target() 当前被点击的元素 七、自定义事件 自定义不带参数事件 12345let ev = new Event('cat');document.addEventListener('cat',function() &#123; console.log('自定义不带参数事件');&#125;)document.dispatchEvent(ev); 自定义可以传参事件 1234567let ev = new CustomEvent('dog',&#123; detail: &#123; a : '参数a'&#125;&#125;);document.addEventListener('dog',function(e) &#123; console.log('自定义事件参数为',e.detail);&#125;)document.dispatchEvent(ev); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;自定义事件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;按钮1&lt;/button&gt; &lt;button id="btn2"&gt;按钮2&lt;/button&gt; &lt;/div&gt; &lt;script&gt; &#123; // 一、 自定义一个不可传参事件 // new 一个custon事件对象，事件名为custom let event = new Event('custom'); // 监听自定义事件 document.addEventListener('custom', function () &#123; console.log('自定义事件') &#125;) let btn = document.getElementById('btn'); btn.addEventListener('click', function () &#123; console.log('click事件'); // 触发自定义事件 document.dispatchEvent(event); &#125;) &#125; &lt;/script&gt; &lt;script&gt; &#123; // 自定义一个传参事件 // new 一个自定义事件对象，并且传递参数 /* * bubbles : 是否冒泡 * cancelable ： 是否可取消该事件 * detail : 需要传递的事件参数 */ let event_2 = new CustomEvent('customEvent', &#123; bubbles: 'true', cancelable: 'true', detail : &#123; a: '参数a', b: '参数b' &#125;&#125; ); // 监听自定义事件 document.addEventListener('customEvent', function (e) &#123; console.log('自定义事件,参数为:', e); &#125;) let btn_2 = document.getElementById("btn2"); btn_2.addEventListener('click',function()&#123; console.log('clcik事件2'); document.dispatchEvent(event_2); &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两栏布局（左侧固定，右侧自适应）]]></title>
    <url>%2F2018%2F12%2F19%2F%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[css实现左侧宽度固定，右侧自适应布局的四种方法1. 左侧浮动，右侧生成BFC123456789&lt;div className = &#123; style['float-left-center'] &#125;&gt; &lt;div className=&#123; style.left &#125;&gt;&lt;/div&gt; &lt;div className=&#123; style.right &#125;&gt; &lt;p&gt;左侧浮动的两栏内容&lt;/p&gt; &lt;p&gt;左侧浮动的两栏内容&lt;/p&gt; &lt;p&gt;左侧浮动的两栏内容&lt;/p&gt; &lt;p&gt;左侧浮动的两栏内容&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 1234567891011121314151617// 左侧浮动，右侧生成BFC.float-left-center &#123; margin: 5px 0; width: 100%; color: blue; .left &#123; float: left; width: 300px;; height: 100px; background: red; &#125; .right &#123; background: #eee; //height: 100px; overflow: auto; &#125;&#125; 2. flex布局实现12345678910&lt;div className=&#123; style['flex-left-center']&#125;&gt; &lt;div className=&#123; style.left &#125;&gt;&lt;/div&gt; &lt;div className=&#123; style.right &#125;&gt; &lt;p&gt;flex布局，左侧固定&lt;/p&gt; &lt;p&gt;flex布局，左侧固定&lt;/p&gt; &lt;p&gt;flex布局，左侧固定&lt;/p&gt; &lt;p&gt;flex布局，左侧固定&lt;/p&gt; &lt;p&gt;flex布局，左侧固定&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314/*flex布局实现*/.flex-left-center &#123; display: flex; margin: 5px 0; .left &#123; width: 300px; height: 100px; background: red; &#125; .right&#123; flex: 1; background: #eee; &#125;&#125; 3. css3 网格布局12345678910&lt;div className=&#123; style[&apos;grid-left-center&apos;]&#125;&gt; &lt;div className=&#123; style.left &#125;&gt;&lt;/div&gt; &lt;div className=&#123; style.right &#125;&gt; &lt;p&gt;网格布局实现&lt;/p&gt; &lt;p&gt;网格布局实现&lt;/p&gt; &lt;p&gt;网格布局实现&lt;/p&gt; &lt;p&gt;网格布局实现&lt;/p&gt; &lt;p&gt;网格布局实现&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314// 网格布局.grid-left-center &#123; margin: 5px 0; display: grid; grid-template-columns: 300px auto; grid-template-rows: 200px auto; .left &#123; background: red; &#125; .right &#123; background: #eee; &#125;&#125; 4. 绝对定位实现12345678910&lt;div className=&#123; style['absoulte-left-center']&#125;&gt; &lt;div className=&#123; style.left &#125;&gt;&lt;/div&gt; &lt;div className=&#123; style.right &#125;&gt; &lt;p&gt;绝对定位实现&lt;/p&gt; &lt;p&gt;绝对定位实现&lt;/p&gt; &lt;p&gt;绝对定位实现&lt;/p&gt; &lt;p&gt;绝对定位实现&lt;/p&gt; &lt;p&gt;绝对定位实现&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617// 绝对定位实现.absoulte-left-center &#123; position: relative; margin: 5px 0; .left &#123; position: absolute; width: 300px; height: 100px; background: red; &#125; .right &#123; position: absolute; left: 300px; right: 0; background: #eee; &#125;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
</search>
